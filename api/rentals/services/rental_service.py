"""
RentalService - Individual Service File
============================================================

Service for rental operations

Auto-generated by Service Splitter
Date: 2025-10-17
"""

from __future__ import annotations

from typing import Dict, Any, Optional, Tuple
from decimal import Decimal
from django.db import transaction
from django.utils import timezone
from django.db.models import Count, Sum
from api.common.services.base import CRUDService, ServiceException
from api.common.utils.helpers import generate_rental_code, paginate_queryset
from api.rentals.models import (
    Rental, RentalExtension, RentalPackage
)
from api.stations.models import Station, StationSlot, PowerBank
from api.common.permissions.base import CanRentPowerBank


class RentalService(CRUDService):
    """Service for rental operations"""
    model = Rental
    
    @transaction.atomic
    def start_rental(self, user, station_sn: str, package_id: str) -> Rental:
        """
        Start a new rental session.
        
        Payment flow is determined by package.payment_model:
        - PREPAID: Points + wallet charged immediately, rental starts
        - POSTPAID: Rental starts, payment charged at return
        
        Points are always used first, then wallet balance.
        """
        try:
            # Validate prerequisites
            self._validate_rental_prerequisites(user)
            
            # Get station and package
            station = Station.objects.get(serial_number=station_sn)
            package = RentalPackage.objects.get(id=package_id, is_active=True)
            
            # Validate station availability
            self._validate_station_availability(station)
            
            # Get available power bank and slot
            power_bank, slot = self._get_available_power_bank_and_slot(station)
            
            # FIX #5: Validate POSTPAID minimum balance requirement
            if package.payment_model == 'POSTPAID':
                self._validate_postpaid_balance(user)
            
            # CRITICAL FIX: Create rental FIRST (in PENDING status)
            # This allows transaction to be linked to rental
            rental = Rental.objects.create(
                user=user,
                station=station,
                slot=slot,
                package=package,
                power_bank=power_bank,
                rental_code=generate_rental_code(),
                status='PENDING',  # Will be set to ACTIVE after payment
                due_at=timezone.now() + timezone.timedelta(minutes=package.duration_minutes),
                amount_paid=Decimal('0')  # Will be updated after payment
            )
            
            # Process payment based on package payment model
            payment_transaction = None
            if package.payment_model == 'PREPAID':
                payment_transaction = self._process_prepayment(user, package, rental)
                # Update rental amount after payment
                rental.amount_paid = package.price
                rental.save(update_fields=['amount_paid'])
            
            # Assign power bank to rental
            from api.stations.services import PowerBankService
            powerbank_service = PowerBankService()
            powerbank_service.assign_power_bank_to_rental(power_bank, rental)
            
            # Start the rental
            rental.status = 'ACTIVE'
            rental.started_at = timezone.now()
            rental.payment_status = 'PAID' if package.payment_model == 'PREPAID' else 'PENDING'
            rental.save(update_fields=['status', 'started_at', 'payment_status'])
            
            # Schedule reminder notification (15 minutes before due)
            reminder_time = rental.due_at - timezone.timedelta(minutes=15)
            if reminder_time > timezone.now():
                from api.notifications.tasks import send_notification_task
                send_notification_task.apply_async(
                    args=[str(user.id), 'rental_reminder', {
                        'rental_id': str(rental.id),
                        'rental_code': rental.rental_code,
                        'due_time': rental.due_at.strftime('%H:%M')
                    }],
                    eta=reminder_time
                )
            
            # Send rental start notification using clean API
            from api.notifications.services import notify
            notify(
                user,
                'rental_started',
                async_send=True,
                powerbank_serial=power_bank.serial_number,
                station_name=station.station_name,
                rental_duration=24
            )
            
            self.log_info(f"Rental started: {rental.rental_code} by {user.username}")
            return rental
            
        except Exception as e:
            self.handle_service_error(e, "Failed to start rental")
    
    def _validate_rental_prerequisites(self, user) -> None:
        """Validate user can start rental"""
        permission = CanRentPowerBank()
        
        # Mock request object for permission check
        class MockRequest:
            def __init__(self, user):
                self.user = user
        
        mock_request = MockRequest(user)
        
        if not permission.has_permission(mock_request, None):
            raise ServiceException(
                detail="User does not meet rental requirements",
                code="rental_prerequisites_not_met"
            )
        
        # Check for active rental
        active_rental = Rental.objects.filter(
            user=user,
            status__in=['PENDING', 'ACTIVE']
        ).first()
        
        if active_rental:
            raise ServiceException(
                detail="You already have an active rental",
                code="active_rental_exists"
            )
    
    def _validate_station_availability(self, station: Station) -> None:
        """Validate station is available for rental"""
        if station.status != 'ONLINE':
            raise ServiceException(
                detail="Station is not online",
                code="station_offline"
            )
        
        if station.is_maintenance:
            raise ServiceException(
                detail="Station is under maintenance",
                code="station_maintenance"
            )
    
    def _validate_postpaid_balance(self, user) -> None:
        """
        Validate user has minimum balance for POSTPAID rentals.
        
        POSTPAID rentals allow users to pay after returning the powerbank.
        However, we require a minimum wallet balance to ensure payment capability
        and reduce risk of unpaid rentals.
        """
        from api.system.models import AppConfig
        
        # Get minimum balance requirement from AppConfig (default NPR 50)
        min_balance = Decimal(AppConfig.objects.filter(
            key='POSTPAID_MINIMUM_BALANCE', is_active=True
        ).values_list('value', flat=True).first() or '50')
        
        # Get user's wallet balance
        wallet_balance = Decimal('0')
        if hasattr(user, 'wallet') and user.wallet:
            wallet_balance = user.wallet.balance
        
        if wallet_balance < min_balance:
            raise ServiceException(
                detail=f"POSTPAID rentals require minimum wallet balance of NPR {min_balance}. Your balance: NPR {wallet_balance}. Please top up your wallet.",
                code="insufficient_postpaid_balance"
            )
        
        self.log_info(f"POSTPAID balance check passed for user {user.username}: NPR {wallet_balance} >= NPR {min_balance}")
    
    def _get_available_power_bank_and_slot(self, station: Station) -> Tuple[PowerBank, StationSlot]:
        """Get available power bank and slot from station"""
        # CRITICAL FIX: Use select_for_update() to prevent race conditions
        # Lock the slot row until transaction completes
        available_slot = station.slots.select_for_update().filter(
            status='AVAILABLE'
        ).order_by('-battery_level').first()
        
        if not available_slot:
            raise ServiceException(
                detail="No available slots at this station",
                code="no_available_slots"
            )
        
        # Find power bank in the slot with row-level lock
        power_bank = PowerBank.objects.select_for_update().filter(
            current_station=station,
            current_slot=available_slot,
            status='AVAILABLE',
            battery_level__gte=20  # Minimum 20% battery
        ).first()
        
        if not power_bank:
            raise ServiceException(
                detail="No power bank available with sufficient battery",
                code="no_power_bank_available"
            )
        
        return power_bank, available_slot
    
    def _process_prepayment(self, user, package: RentalPackage, rental=None):
        """Process pre-payment for rental"""
        from api.payments.services import PaymentCalculationService, RentalPaymentService
        
        # Calculate payment options
        calc_service = PaymentCalculationService()
        payment_options = calc_service.calculate_payment_options(
            user=user,
            scenario='pre_payment',
            package_id=str(package.id),
            amount=package.price
        )
        
        if not payment_options['is_sufficient']:
            raise ServiceException(
                detail=f"Insufficient balance. Need NPR {payment_options['shortfall']} more.",
                code="insufficient_balance"
            )
        
        # Process payment with rental link
        payment_service = RentalPaymentService()
        transaction = payment_service.process_rental_payment(
            user=user,
            rental=rental,  # FIXED: Now rental is passed correctly
            payment_breakdown=payment_options['payment_breakdown']
        )
        
        return transaction
    
    @transaction.atomic
    def cancel_rental(self, rental_id: str, user, reason: str = "") -> Rental:
        """Cancel an active rental"""
        try:
            rental = Rental.objects.get(id=rental_id, user=user)
            
            if rental.status not in ['PENDING', 'ACTIVE']:
                raise ServiceException(
                    detail="Rental cannot be cancelled in current status",
                    code="invalid_rental_status"
                )
            
            # Check if rental can be cancelled (configurable time window)
            if rental.started_at:
                from api.system.models import AppConfig
                
                # Get cancellation window from AppConfig (default 5 minutes)
                cancellation_window_minutes = int(AppConfig.objects.filter(
                    key='RENTAL_CANCELLATION_WINDOW_MINUTES', is_active=True
                ).values_list('value', flat=True).first() or 5)
                
                time_since_start = timezone.now() - rental.started_at
                cancellation_window_seconds = cancellation_window_minutes * 60
                
                if time_since_start.total_seconds() > cancellation_window_seconds:
                    raise ServiceException(
                        detail=f"Rental can only be cancelled within {cancellation_window_minutes} minutes of start",
                        code="cancellation_time_expired"
                    )
            
            # CRITICAL FIX: Verify powerbank is physically back in station
            # This prevents users from taking powerbank and cancelling for free
            if rental.power_bank and rental.status == 'ACTIVE':
                # Check database state first
                if rental.power_bank.current_station != rental.station:
                    raise ServiceException(
                        detail="Cannot cancel rental. Please return powerbank to station first.",
                        code="powerbank_not_returned"
                    )
                
                if rental.power_bank.current_slot is None:
                    raise ServiceException(
                        detail="Cannot cancel rental. Powerbank not detected in any slot.",
                        code="powerbank_not_in_slot"
                    )
                
                # Verify slot is occupied (powerbank is physically there)
                if rental.slot.status != 'OCCUPIED':
                    raise ServiceException(
                        detail="Cannot cancel rental. Powerbank must be inserted back in slot.",
                        code="slot_not_occupied"
                    )
                
                # Additional safety: Check battery level was recently updated
                # (indicates recent sync from IoT system)
                if rental.power_bank.updated_at:
                    time_since_update = timezone.now() - rental.power_bank.updated_at
                    if time_since_update.total_seconds() > 60:  # 1 minute threshold
                        self.log_warning(
                            f"Powerbank {rental.power_bank.serial_number} location data is stale "
                            f"({time_since_update.total_seconds():.0f}s old). Allowing cancellation with caution."
                        )
            
            # Update rental status
            rental.status = 'CANCELLED'
            rental.ended_at = timezone.now()
            rental.rental_metadata['cancellation_reason'] = reason
            rental.save(update_fields=['status', 'ended_at', 'rental_metadata'])
            
            # Release power bank and slot - FIXED: Restore to original location
            if rental.power_bank:
                rental.power_bank.status = 'AVAILABLE'
                # Restore to original station/slot
                rental.power_bank.current_station = rental.station
                rental.power_bank.current_slot = rental.slot
                rental.power_bank.save(update_fields=['status', 'current_station', 'current_slot'])
            
            if rental.slot:
                rental.slot.status = 'AVAILABLE'
                rental.slot.current_rental = None
                rental.slot.save(update_fields=['status', 'current_rental'])
            
            # FIXED: Process proper refund (points + wallet)
            if rental.payment_status == 'PAID' and rental.amount_paid > 0:
                from api.payments.models import Transaction
                from api.payments.services import WalletService
                
                # Find original payment transaction to get breakdown
                original_txn = Transaction.objects.filter(
                    related_rental=rental,
                    transaction_type='RENTAL',
                    status='SUCCESS'
                ).first()
                
                if original_txn:
                    payment_method = original_txn.payment_method_type
                    
                    # Refund points if used
                    if payment_method in ['POINTS', 'COMBINATION']:
                        points_used = original_txn.gateway_response.get('points_used', 0)
                        if points_used > 0:
                            from api.points.services import award_points
                            award_points(
                                user, 
                                points_used, 
                                'REFUND', 
                                f'Points refund for cancelled rental {rental.rental_code}',
                                async_send=False
                            )
                    
                    # Refund wallet if used
                    if payment_method in ['WALLET', 'COMBINATION']:
                        wallet_amount = original_txn.gateway_response.get('wallet_amount', rental.amount_paid)
                        wallet_service = WalletService()
                        wallet_service.add_balance(
                            user=user,
                            amount=wallet_amount,
                            description=f"Wallet refund for cancelled rental {rental.rental_code}"
                        )
                    
                    # Update transaction status to refunded
                    original_txn.status = 'REFUNDED'
                    original_txn.save(update_fields=['status'])
                    
                    rental.payment_status = 'REFUNDED'
                    rental.save(update_fields=['payment_status'])
                else:
                    # Fallback: refund to wallet if no transaction found
                    wallet_service = WalletService()
                    wallet_service.add_balance(
                        user=user,
                        amount=rental.amount_paid,
                        description=f"Refund for cancelled rental {rental.rental_code}"
                    )
            
            self.log_info(f"Rental cancelled: {rental.rental_code}")
            return rental
            
        except Rental.DoesNotExist:
            raise ServiceException(
                detail="Rental not found",
                code="rental_not_found"
            )
        except Exception as e:
            self.handle_service_error(e, "Failed to cancel rental")
    
    @transaction.atomic
    def extend_rental(self, rental_id: str, user, package_id: str) -> RentalExtension:
        """Extend rental duration"""
        try:
            # FIX #4: Lock rental row to prevent race conditions
            rental = Rental.objects.select_for_update().get(id=rental_id, user=user)
            package = RentalPackage.objects.get(id=package_id, is_active=True)
            
            if rental.status != 'ACTIVE':
                raise ServiceException(
                    detail="Only active rentals can be extended",
                    code="invalid_rental_status"
                )
            
            # FIX #2: Check if rental is already overdue
            if timezone.now() >= rental.due_at:
                raise ServiceException(
                    detail="Cannot extend overdue rental. Please return powerbank.",
                    code="rental_overdue"
                )
            
            # FIX #1: Check extension limit
            from api.system.models import AppConfig
            max_extensions = int(AppConfig.objects.filter(
                key='MAX_RENTAL_EXTENSIONS', is_active=True
            ).values_list('value', flat=True).first() or 3)
            
            extension_count = rental.extensions.count()
            if extension_count >= max_extensions:
                raise ServiceException(
                    detail=f"Maximum {max_extensions} extensions allowed per rental",
                    code="max_extensions_reached"
                )
            
            # Check payment for extension
            from api.payments.services import PaymentCalculationService, RentalPaymentService
            
            calc_service = PaymentCalculationService()
            payment_options = calc_service.calculate_payment_options(
                user=user,
                scenario='pre_payment',
                package_id=package_id
            )
            
            if not payment_options['is_sufficient']:
                raise ServiceException(
                    detail=f"Insufficient balance for extension. Need NPR {payment_options['shortfall']} more.",
                    code="insufficient_balance"
                )
            
            # Process payment
            payment_service = RentalPaymentService()
            payment_service.process_rental_payment(
                user=user,
                rental=rental,
                payment_breakdown=payment_options['payment_breakdown']
            )
            
            # Create extension record
            extension = RentalExtension.objects.create(
                rental=rental,
                package=package,
                created_by=user,
                extended_minutes=package.duration_minutes,
                extension_cost=package.price
            )
            
            # Update rental due time
            old_due_at = rental.due_at
            rental.due_at += timezone.timedelta(minutes=package.duration_minutes)
            rental.amount_paid += package.price
            rental.save(update_fields=['due_at', 'amount_paid'])
            
            # FIX #3: Send extension notification
            from api.notifications.services import notify
            notify(
                user,
                'rental_extended',
                async_send=True,
                rental_code=rental.rental_code,
                extended_minutes=package.duration_minutes,
                extension_cost=float(package.price),
                old_due_time=old_due_at.strftime('%H:%M'),
                new_due_time=rental.due_at.strftime('%H:%M')
            )
            
            self.log_info(f"Rental extended: {rental.rental_code} by {package.duration_minutes} minutes (Extension #{extension_count + 1})")
            return extension
            
        except (Rental.DoesNotExist, RentalPackage.DoesNotExist):
            raise ServiceException(
                detail="Rental or package not found",
                code="not_found"
            )
        except Exception as e:
            self.handle_service_error(e, "Failed to extend rental")
    
    @transaction.atomic
    def return_power_bank(self, rental_id: str, return_station_sn: str, 
                         return_slot_number: int, battery_level: int = 50) -> Rental:
        """Return power bank to station (Internal use - triggered by hardware)"""
        try:
            # FIX #8: Idempotency check - if already processed, return existing result
            rental = Rental.objects.select_for_update().get(id=rental_id)
            
            if rental.status != 'ACTIVE':
                # Already processed - return idempotent response
                self.log_warning(f"Return already processed for rental {rental.rental_code} (status: {rental.status})")
                return rental
            
            return_station = Station.objects.get(serial_number=return_station_sn)
            return_slot = return_station.slots.get(slot_number=return_slot_number)
            
            # End rental
            rental.status = 'COMPLETED'
            rental.ended_at = timezone.now()
            rental.return_station = return_station
            
            # Check if returned on time
            rental.is_returned_on_time = rental.ended_at <= rental.due_at
            
            # Calculate overdue charges for post-payment model
            if rental.package.payment_model == 'POSTPAID':
                self._calculate_postpayment_charges(rental)
            elif not rental.is_returned_on_time:
                self._calculate_overdue_charges(rental)
            
            rental.save(update_fields=[
                'status', 'ended_at', 'return_station', 'is_returned_on_time',
                'overdue_amount', 'payment_status'
            ])
            
            # FIXED: Auto-collect pending payments
            if rental.payment_status == 'PENDING':
                self._auto_collect_payment(rental)
            
            # Return power bank to station
            from api.stations.services import PowerBankService
            powerbank_service = PowerBankService()
            powerbank_service.return_power_bank(
                rental.power_bank, return_station, return_slot, rental=rental
            )
            
            # Award completion points
            from api.points.services import award_points
            from api.system.models import AppConfig
            
            # Standard completion points
            completion_points = int(AppConfig.objects.filter(
                key='POINTS_RENTAL_COMPLETE', is_active=True
            ).values_list('value', flat=True).first() or 5)
            
            award_points(
                rental.user,
                completion_points,
                'RENTAL',
                'Rental completion reward',
                async_send=True,
                rental_id=str(rental.id),
                on_time=rental.is_returned_on_time
            )
            
            # FIXED: Award timely return bonus
            if rental.is_returned_on_time and not rental.timely_return_bonus_awarded:
                timely_bonus = int(AppConfig.objects.filter(
                    key='POINTS_TIMELY_RETURN', is_active=True
                ).values_list('value', flat=True).first() or 50)
                
                award_points(
                    rental.user,
                    timely_bonus,
                    'ON_TIME_RETURN',
                    f'On-time return bonus for {rental.rental_code}',
                    async_send=True
                )
                rental.timely_return_bonus_awarded = True
                rental.save(update_fields=['timely_return_bonus_awarded'])
            
            # Send completion notification
            from api.notifications.services import notify
            notify(
                rental.user,
                'rental_completed',
                async_send=True,
                powerbank_serial=rental.power_bank.serial_number,
                amount_paid=float(rental.amount_paid),
                rental_code=rental.rental_code
            )
            
            self.log_info(f"Power bank returned: {rental.rental_code}")
            return rental
            
        except Exception as e:
            self.handle_service_error(e, "Failed to return power bank")
    
    def _calculate_postpayment_charges(self, rental: Rental) -> None:
        """Calculate charges for post-payment model"""
        if not rental.ended_at or not rental.started_at:
            return
        
        # Calculate actual usage time
        usage_duration = rental.ended_at - rental.started_at
        usage_minutes = int(usage_duration.total_seconds() / 60)
        
        # Calculate cost based on package rate
        package_rate_per_minute = rental.package.price / rental.package.duration_minutes
        total_cost = Decimal(str(usage_minutes)) * package_rate_per_minute
        
        rental.amount_paid = total_cost
        rental.payment_status = 'PENDING'
    
    def _calculate_overdue_charges(self, rental: Rental) -> None:
        """Calculate overdue charges for late returns"""
        if rental.is_returned_on_time or not rental.ended_at:
            return
        
        # Calculate overdue time using configurable rates
        from api.common.utils.helpers import calculate_overdue_minutes, calculate_late_fee_amount, get_package_rate_per_minute
        overdue_minutes = calculate_overdue_minutes(rental)
        package_rate_per_minute = get_package_rate_per_minute(rental.package)
        rental.overdue_amount = calculate_late_fee_amount(package_rate_per_minute, overdue_minutes)
        
        if rental.overdue_amount > 0:
            rental.payment_status = 'PENDING'
    
    def _auto_collect_payment(self, rental: Rental) -> None:
        """
        Automatically collect pending payments (POSTPAID charges or late fees).
        Tries to deduct from user's points/wallet. If insufficient, sends notification.
        """
        try:
            from api.payments.services import PaymentCalculationService, RentalPaymentService
            
            # Calculate total amount due
            total_due = rental.amount_paid + rental.overdue_amount
            
            if total_due <= 0:
                return
            
            # Calculate payment options (points first, then wallet)
            calc_service = PaymentCalculationService()
            payment_options = calc_service.calculate_payment_options(
                user=rental.user,
                scenario='post_payment',  # Use post_payment for dues settlement
                rental_id=str(rental.id)
            )
            
            if payment_options['is_sufficient']:
                # User has sufficient balance - auto-collect
                payment_service = RentalPaymentService()
                try:
                    payment_service.pay_rental_due(
                        rental.user,
                        rental,
                        payment_options['payment_breakdown']
                    )
                    self.log_info(f"Auto-collected NPR {total_due} for rental {rental.rental_code}")
                except Exception as e:
                    # Payment failed - log and notify user
                    self.log_warning(f"Auto-collection failed for {rental.rental_code}: {str(e)}")
                    self._notify_payment_failed(rental, total_due)
            else:
                # Insufficient balance - notify user to pay manually
                self.log_info(f"Insufficient balance for auto-collection: {rental.rental_code} (Need NPR {total_due})")
                self._notify_payment_required(rental, total_due, payment_options['shortfall'])
                
        except Exception as e:
            # Don't let auto-collection errors break the return process
            self.log_error(f"Auto-collection error for {rental.rental_code}: {str(e)}")
            self._notify_payment_required(rental, total_due, 0)
    
    def _notify_payment_failed(self, rental: Rental, amount: Decimal) -> None:
        """Notify user that auto-payment failed"""
        try:
            from api.notifications.services import notify
            notify(
                rental.user,
                'payment_failed',
                async_send=True,
                rental_code=rental.rental_code,
                amount=float(amount),
                reason='Auto-payment processing failed'
            )
        except Exception as e:
            self.log_error(f"Failed to send payment failed notification: {str(e)}")
    
    def _notify_payment_required(self, rental: Rental, amount: Decimal, shortfall: Decimal) -> None:
        """Notify user to pay manually"""
        try:
            from api.notifications.services import notify
            notify(
                rental.user,
                'payment_due',
                async_send=True,
                rental_code=rental.rental_code,
                amount=float(amount),
                shortfall=float(shortfall),
                message=f"Outstanding dues for rental {rental.rental_code}. Please add NPR {shortfall} to your account."
            )
        except Exception as e:
            self.log_error(f"Failed to send payment required notification: {str(e)}")
    
    def get_user_rentals(self, user, filters: Dict[str, Any] = None) -> Dict[str, Any]:
        """Get user's rental history with filters"""
        try:
            queryset = Rental.objects.filter(user=user).select_related(
                'station', 'return_station', 'package', 'power_bank'
            )
            
            # Apply filters
            if filters:
                if filters.get('status'):
                    queryset = queryset.filter(status=filters['status'])
                
                if filters.get('payment_status'):
                    queryset = queryset.filter(payment_status=filters['payment_status'])
                
                if filters.get('start_date'):
                    queryset = queryset.filter(created_at__gte=filters['start_date'])
                
                if filters.get('end_date'):
                    queryset = queryset.filter(created_at__lte=filters['end_date'])
                
                if filters.get('station_id'):
                    queryset = queryset.filter(station_id=filters['station_id'])
            
            # Order by latest first
            queryset = queryset.order_by('-created_at')
            
            # Pagination
            page = filters.get('page', 1) if filters else 1
            page_size = filters.get('page_size', 20) if filters else 20
            
            return paginate_queryset(queryset, page, page_size)
            
        except Exception as e:
            self.handle_service_error(e, "Failed to get user rentals")
    
    def get_active_rental(self, user) -> Optional[Rental]:
        """Get user's active rental"""
        try:
            return Rental.objects.filter(
                user=user,
                status__in=['PENDING', 'ACTIVE']
            ).select_related('station', 'package', 'power_bank').first()
        except Exception as e:
            self.handle_service_error(e, "Failed to get active rental")
    
    def get_rental_stats(self, user) -> Dict[str, Any]:
        """Get user's rental statistics"""
        try:
            rentals = Rental.objects.filter(user=user)
            
            # Basic counts
            total_rentals = rentals.count()
            completed_rentals = rentals.filter(status='COMPLETED').count()
            active_rentals = rentals.filter(status__in=['PENDING', 'ACTIVE']).count()
            cancelled_rentals = rentals.filter(status='CANCELLED').count()
            
            # Financial stats
            total_spent = rentals.filter(payment_status='PAID').aggregate(
                total=Sum('amount_paid')
            )['total'] or Decimal('0')
            
            # Time stats
            completed_with_time = rentals.filter(
                status='COMPLETED',
                started_at__isnull=False,
                ended_at__isnull=False
            )
            
            total_time_used = 0
            if completed_with_time.exists():
                for rental in completed_with_time:
                    duration = rental.ended_at - rental.started_at
                    total_time_used += int(duration.total_seconds() / 60)
            
            average_duration = total_time_used / completed_rentals if completed_rentals > 0 else 0
            
            # Return stats
            timely_returns = rentals.filter(is_returned_on_time=True).count()
            late_returns = completed_rentals - timely_returns
            timely_return_rate = (timely_returns / completed_rentals * 100) if completed_rentals > 0 else 0
            
            # Favorites
            favorite_station = rentals.values('station__station_name').annotate(
                count=Count('id')
            ).order_by('-count').first()
            
            favorite_package = rentals.values('package__name').annotate(
                count=Count('id')
            ).order_by('-count').first()
            
            # Dates
            first_rental = rentals.order_by('created_at').first()
            last_rental = rentals.order_by('-created_at').first()
            
            return {
                'total_rentals': total_rentals,
                'completed_rentals': completed_rentals,
                'active_rentals': active_rentals,
                'cancelled_rentals': cancelled_rentals,
                'total_spent': total_spent,
                'total_time_used': total_time_used,
                'average_rental_duration': round(average_duration, 1),
                'timely_returns': timely_returns,
                'late_returns': late_returns,
                'timely_return_rate': round(timely_return_rate, 1),
                'favorite_station': favorite_station['station__station_name'] if favorite_station else None,
                'favorite_package': favorite_package['package__name'] if favorite_package else None,
                'first_rental_date': first_rental.created_at if first_rental else None,
                'last_rental_date': last_rental.created_at if last_rental else None
            }
            
        except Exception as e:
            self.handle_service_error(e, "Failed to get rental stats")
