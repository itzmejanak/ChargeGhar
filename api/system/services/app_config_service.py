"""
Service for AppConfig operations
============================================================

This module contains service classes for service for appconfig operations.

Auto-generated by Service Separator
Date: 2025-10-18 23:47:47
"""
from __future__ import annotations

from typing import Any, Dict
from django.core.cache import cache
from api.common.services.base import CRUDService
from api.system.models import AppConfig

class AppConfigService(CRUDService):
    """Service for AppConfig operations"""
    model = AppConfig
    
    def get_config(self, key: str, default: Any = None) -> Any:
        """Get configuration value by key"""
        try:
            config = self.model.objects.get(key=key, is_active=True)
            return config.value
        except self.model.DoesNotExist:
            return default
    
    def set_config(self, key: str, value: str, description: str = None) -> AppConfig:
        """Set configuration value"""
        try:
            config, created = self.model.objects.update_or_create(
                key=key,
                defaults={
                    'value': str(value),
                    'description': description,
                    'is_active': True
                }
            )
            
            # Clear cache for this config
            cache.delete(f"app_config_{key}")
            
            action = "created" if created else "updated"
            self.log_info(f"Configuration {key} {action}")
            
            return config
            
        except Exception as e:
            self.handle_service_error(e, f"Failed to set config {key}")
    
    def get_config_cached(self, key: str, default: Any = None, timeout: int = 3600) -> Any:
        """Get configuration value with caching"""
        cache_key = f"app_config_{key}"
        value = cache.get(cache_key)
        
        if value is None:
            value = self.get_config(key, default)
            cache.set(cache_key, value, timeout)
        
        return value
    
    def get_public_configs(self) -> Dict[str, str]:
        """Get all public (non-sensitive) configurations"""
        sensitive_keywords = ['secret', 'password', 'key', 'token', 'url']
        
        configs = self.model.objects.filter(is_active=True)
        public_configs = {}
        
        for config in configs:
            if not any(keyword in config.key.lower() for keyword in sensitive_keywords):
                public_configs[config.key] = config.value
        
        return public_configs
    
    # Admin methods
    def get_all_configs(self) -> Dict[str, Any]:
        """Get all configurations (admin can see sensitive ones too)"""
        try:
            configs = self.model.objects.filter(is_active=True).order_by('key')
            return {
                config.key: {
                    'value': config.value,
                    'description': config.description,
                    'is_public': not any(keyword in config.key.lower() 
                                       for keyword in ['secret', 'password', 'key', 'token', 'url']),
                    'created_at': config.created_at,
                    'updated_at': config.updated_at
                }
                for config in configs
            }
        except Exception as e:
            self.handle_service_error(e, "Failed to get all configs")
    
    def create_config(self, key: str, value: str, description: str = None, 
                     is_public: bool = False, admin_user=None) -> AppConfig:
        """Create new configuration with enhanced error handling"""
        try:
            # Check for duplicates first with enhanced error
            if self.model.objects.filter(key=key).exists():
                from api.common.services.base import ServiceException
                from rest_framework import status
                raise ServiceException(
                    detail=f"Configuration with key '{key}' already exists",
                    code="config_already_exists",
                    status_code=status.HTTP_409_CONFLICT,
                    context={'existing_key': key},
                    user_message=f"A configuration with the key '{key}' already exists. Please use a different key."
                )
            
            config = self.model.objects.create(
                key=key,
                value=str(value),
                description=description,
                is_active=True
            )
            
            # Clear cache
            cache.delete(f"app_config_{key}")
            
            # Log admin action
            if admin_user:
                from api.admin.models import AdminActionLog
                AdminActionLog.objects.create(
                    admin_user=admin_user,
                    action_type='CREATE_CONFIG',
                    target_model='AppConfig',
                    target_id=str(config.id),
                    changes={
                        'key': key,
                        'value': value,
                        'description': description
                    },
                    description=f"Created config: {key}",
                    ip_address="127.0.0.1",
                    user_agent="Admin Panel"
                )
            
            self.log_info(f"Configuration created: {key}")
            return config
            
        except ServiceException:
            # Re-raise ServiceException as-is (it already has enhanced context)
            raise
        except Exception as e:
            # Enhanced error handling for unexpected errors
            from api.common.services.base import ServiceException
            from rest_framework import status
            raise ServiceException(
                detail="Failed to create configuration",
                code="config_creation_failed",
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                context={
                    'config_key': key,
                    'admin_user_id': str(admin_user.id) if admin_user else None,
                    'original_error': str(e)
                },
                user_message=f"Unable to create configuration '{key}'. Please try again."
            )
    
    def update_config(self, config_id: str = None, key: str = None, value: str = None, 
                     description: str = None, is_public: bool = None, admin_user=None) -> AppConfig:
        """Update configuration (Admin)"""
        try:
            if config_id:
                config = self.model.objects.get(id=config_id)
            elif key:
                config = self.model.objects.get(key=key)
            else:
                raise ValueError("Either config_id or key is required")
            
            old_values = {
                'value': config.value,
                'description': config.description
            }
            
            if value is not None:
                config.value = str(value)
            if description is not None:
                config.description = description
            
            config.save()
            
            # Clear cache
            cache.delete(f"app_config_{config.key}")
            
            # Log admin action
            if admin_user:
                from api.admin.models import AdminActionLog
                AdminActionLog.objects.create(
                    admin_user=admin_user,
                    action_type='UPDATE_CONFIG',
                    target_model='AppConfig',
                    target_id=str(config.id),
                    changes={
                        'key': config.key,
                        'old_value': old_values['value'],
                        'new_value': config.value,
                        'old_description': old_values['description'],
                        'new_description': config.description
                    },
                    description=f"Updated config: {config.key}",
                    ip_address="127.0.0.1",
                    user_agent="Admin Panel"
                )
            
            self.log_info(f"Configuration updated: {config.key}")
            return config
            
        except self.model.DoesNotExist:
            raise ValueError("Configuration not found")
        except Exception as e:
            self.handle_service_error(e, "Failed to update config")
    
    def delete_config(self, config_id: str = None, key: str = None, admin_user=None) -> str:
        """Delete configuration (Admin)"""
        try:
            if config_id:
                config = self.model.objects.get(id=config_id)
            elif key:
                config = self.model.objects.get(key=key)
            else:
                raise ValueError("Either config_id or key is required")
            
            config_key = config.key
            
            # Log admin action before deletion
            if admin_user:
                from api.admin.models import AdminActionLog
                AdminActionLog.objects.create(
                    admin_user=admin_user,
                    action_type='DELETE_CONFIG',
                    target_model='AppConfig',
                    target_id=str(config.id),
                    changes={
                        'key': config.key,
                        'value': config.value,
                        'description': config.description
                    },
                    description=f"Deleted config: {config.key}",
                    ip_address="127.0.0.1",
                    user_agent="Admin Panel"
                )
            
            # Clear cache
            cache.delete(f"app_config_{config.key}")
            
            config.delete()
            
            self.log_info(f"Configuration deleted: {config_key}")
            return config_key
            
        except self.model.DoesNotExist:
            raise ValueError("Configuration not found")
        except Exception as e:
            self.handle_service_error(e, "Failed to delete config")
