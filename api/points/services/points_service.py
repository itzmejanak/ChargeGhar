"""
PointsService - Individual Service File
============================================================

Service for points operations

Auto-generated by Service Splitter
Date: 2025-10-15
"""

from __future__ import annotations

from typing import Dict, Any, List, TYPE_CHECKING
from django.db import transaction
from django.db.models import Sum
from api.common.services.base import CRUDService, ServiceException
from api.common.utils.helpers import convert_points_to_amount, paginate_queryset
from api.points.models import PointsTransaction, Referral
from api.users.models import UserPoints

if TYPE_CHECKING:
    from api.users.models import User


class PointsService(CRUDService):
    """Service for points operations"""
    model = UserPoints
    
    def get_or_create_user_points(self, user) -> UserPoints:
        """Get or create user points record"""
        try:
            points, created = UserPoints.objects.get_or_create(
                user=user,
                defaults={'current_points': 0, 'total_points': 0}
            )
            return points
        except Exception as e:
            self.handle_service_error(e, "Failed to get or create user points")
    
    @transaction.atomic
    def award_points(self, user, points: int, source: str, description: str, **kwargs) -> PointsTransaction:
        """Award points to user"""
        try:
            user_points = self.get_or_create_user_points(user)
            
            balance_before = user_points.current_points
            user_points.current_points += points
            user_points.total_points += points
            user_points.save(update_fields=['current_points', 'total_points', 'last_updated'])
            
            # Create transaction record
            points_transaction = PointsTransaction.objects.create(
                user=user,
                transaction_type='EARNED',
                source=source,
                points=points,
                balance_before=balance_before,
                balance_after=user_points.current_points,
                description=description,
                metadata=kwargs.get('metadata', {}),
                related_rental=kwargs.get('related_rental'),
                related_referral=kwargs.get('related_referral')
            )
            
            self.log_info(f"Points awarded: {user.username} +{points} ({source})")
            
            # Send notification for points earned (universal notify method)
            from api.notifications.services import notify
            notify(
                user=user,
                template_slug='points_earned',
                async_send=True,  # Non-critical, send async
                points=points,
                new_balance=user_points.current_points,
                description=description,
                source=source
            )
            
            return points_transaction
            
        except Exception as e:
            self.handle_service_error(e, "Failed to award points")
    
    @transaction.atomic
    def deduct_points(self, user, points: int, source: str, description: str, **kwargs) -> PointsTransaction:
        """Deduct points from user"""
        try:
            user_points = self.get_or_create_user_points(user)
            
            if user_points.current_points < points:
                raise ServiceException(
                    detail="Insufficient points balance",
                    code="insufficient_points"
                )
            
            balance_before = user_points.current_points
            user_points.current_points -= points
            user_points.save(update_fields=['current_points', 'last_updated'])
            
            # Create transaction record
            points_transaction = PointsTransaction.objects.create(
                user=user,
                transaction_type='SPENT',
                source=source,
                points=points,
                balance_before=balance_before,
                balance_after=user_points.current_points,
                description=description,
                metadata=kwargs.get('metadata', {}),
                related_rental=kwargs.get('related_rental')
            )
            
            self.log_info(f"Points deducted: {user.username} -{points} ({source})")
            return points_transaction
            
        except Exception as e:
            self.handle_service_error(e, "Failed to deduct points")
    
    @transaction.atomic
    def adjust_points(self, user, points: int, adjustment_type: str, reason: str, admin_user=None) -> PointsTransaction:
        """Admin adjustment of user points"""
        try:
            user_points = self.get_or_create_user_points(user)
            
            balance_before = user_points.current_points
            
            if adjustment_type == 'ADD':
                user_points.current_points += points
                user_points.total_points += points
                transaction_type = 'EARNED'
            else:  # DEDUCT
                if user_points.current_points < points:
                    # Allow negative balance for admin adjustments
                    pass
                user_points.current_points -= points
                transaction_type = 'SPENT'
            
            user_points.save(update_fields=['current_points', 'total_points', 'last_updated'])
            
            # Create transaction record
            points_transaction = PointsTransaction.objects.create(
                user=user,
                transaction_type=transaction_type,
                source='ADMIN_ADJUSTMENT',
                points=points,
                balance_before=balance_before,
                balance_after=user_points.current_points,
                description=reason,
                metadata={
                    'admin_user_id': str(admin_user.id) if admin_user else None,
                    'adjustment_type': adjustment_type
                }
            )
            
            self.log_info(f"Points adjusted by admin: {user.username} {adjustment_type} {points}")
            return points_transaction
            
        except Exception as e:
            self.handle_service_error(e, "Failed to adjust points")
    
    def get_points_history(self, user, filters: Dict[str, Any] = None) -> Dict[str, Any]:
        """Get user's points transaction history - OPTIMIZED with select_related"""
        try:
            # Optimized query with select_related for better performance
            queryset = PointsTransaction.objects.filter(user=user).select_related(
                'related_rental', 'related_referral'
            )
            
            # Apply filters
            if filters:
                if filters.get('transaction_type'):
                    queryset = queryset.filter(transaction_type=filters['transaction_type'])
                
                if filters.get('source'):
                    queryset = queryset.filter(source=filters['source'])
                
                if filters.get('start_date'):
                    queryset = queryset.filter(created_at__gte=filters['start_date'])
                
                if filters.get('end_date'):
                    queryset = queryset.filter(created_at__lte=filters['end_date'])
            
            # Order by latest first with index optimization
            queryset = queryset.order_by('-created_at')
            
            # Pagination
            page = filters.get('page', 1) if filters else 1
            page_size = filters.get('page_size', 20) if filters else 20
            
            return paginate_queryset(queryset, page, page_size)
            
        except Exception as e:
            self.handle_service_error(e, "Failed to get points history")
    
    def get_points_summary(self, user) -> Dict[str, Any]:
        """Get comprehensive points summary for user"""
        try:
            user_points = self.get_or_create_user_points(user)
            
            # Get transaction statistics
            transactions = PointsTransaction.objects.filter(user=user)
            
            # Points breakdown by source
            points_from_signup = transactions.filter(
                transaction_type='EARNED',
                source='SIGNUP'
            ).aggregate(total=Sum('points'))['total'] or 0
            
            points_from_referrals = transactions.filter(
                transaction_type='EARNED',
                source__in=['REFERRAL_INVITER', 'REFERRAL_INVITEE']
            ).aggregate(total=Sum('points'))['total'] or 0
            
            points_from_topups = transactions.filter(
                transaction_type='EARNED',
                source='TOPUP'
            ).aggregate(total=Sum('points'))['total'] or 0
            
            points_from_rentals = transactions.filter(
                transaction_type='EARNED',
                source='RENTAL'
            ).aggregate(total=Sum('points'))['total'] or 0
            
            points_from_timely_returns = transactions.filter(
                transaction_type='EARNED',
                source='TIMELY_RETURN'
            ).aggregate(total=Sum('points'))['total'] or 0
            
            points_from_coupons = transactions.filter(
                transaction_type='EARNED',
                source='COUPON'
            ).aggregate(total=Sum('points'))['total'] or 0
            
            source_breakdown = {
                'points_from_signup': points_from_signup,
                'points_from_referrals': points_from_referrals,
                'points_from_topups': points_from_topups,
                'points_from_rentals': points_from_rentals,
                'points_from_timely_returns': points_from_timely_returns,
                'points_from_coupons': points_from_coupons
            }
            
            # Recent activity
            recent_transactions = transactions.order_by('-created_at')[:10]
            last_earned = transactions.filter(transaction_type='EARNED').order_by('-created_at').first()
            last_spent = transactions.filter(transaction_type='SPENT').order_by('-created_at').first()
            
            # Referral statistics
            referral_stats = self._get_referral_stats(user)
            
            return {
                'current_points': user_points.current_points,
                'total_points_earned': user_points.total_points,
                'total_points_spent': user_points.total_points - user_points.current_points,
                'points_value': convert_points_to_amount(user_points.current_points),
                **source_breakdown,
                'recent_transactions_count': recent_transactions.count(),
                'last_earned_date': last_earned.created_at if last_earned else None,
                'last_spent_date': last_spent.created_at if last_spent else None,
                **referral_stats
            }
            
        except Exception as e:
            self.handle_service_error(e, "Failed to get points summary")
    
    def _get_referral_stats(self, user) -> Dict[str, Any]:
        """Get referral statistics for user"""
        sent_referrals = Referral.objects.filter(inviter=user)
        
        return {
            'total_referrals_sent': sent_referrals.count(),
            'successful_referrals': sent_referrals.filter(status='COMPLETED').count(),
            'pending_referrals': sent_referrals.filter(status='PENDING').count(),
            'referral_points_earned': sent_referrals.aggregate(
                total=Sum('inviter_points_awarded')
            )['total'] or 0
        }
    
    def bulk_award_points(self, user_ids: List[str], points: int, source: str, description: str, admin_user=None) -> Dict[str, Any]:
        """Bulk award points to multiple users"""
        try:
            users = User.objects.filter(id__in=user_ids)
            
            awarded_count = 0
            failed_users = []
            
            for user in users:
                try:
                    self.award_points(
                        user, points, source, description,
                        metadata={'bulk_award': True, 'admin_user_id': str(admin_user.id) if admin_user else None}
                    )
                    awarded_count += 1
                except Exception as e:
                    failed_users.append({'user_id': str(user.id), 'error': str(e)})
            
            self.log_info(f"Bulk points awarded: {awarded_count} users, {points} points each")
            
            return {
                'total_users': len(user_ids),
                'awarded_count': awarded_count,
                'failed_count': len(failed_users),
                'failed_users': failed_users,
                'total_points_awarded': awarded_count * points
            }
            
        except Exception as e:
            self.handle_service_error(e, "Failed to bulk award points")
