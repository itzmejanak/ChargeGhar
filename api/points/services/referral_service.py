"""
ReferralService - Individual Service File
============================================================

Service for referral operations

Auto-generated by Service Splitter
Date: 2025-10-15
"""

from __future__ import annotations

from typing import Dict, Any
from django.db import transaction
from django.utils import timezone
from django.db.models import Sum, Count, Q
from api.common.services.base import CRUDService, ServiceException
from api.common.utils.helpers import paginate_queryset
from api.points.models import Referral
from api.users.models import User


class ReferralService(CRUDService):
    """Service for referral operations"""
    model = Referral
    
    def validate_referral_code(self, referral_code: str, requesting_user=None) -> Dict[str, Any]:
        """Validate referral code"""
        try:
            inviter = User.objects.get(referral_code=referral_code)
            
            # Check if user is trying to refer themselves
            if requesting_user and requesting_user == inviter:
                raise ServiceException(
                    detail="You cannot refer yourself",
                    code="self_referral_not_allowed"
                )
            
            return {
                'valid': True,
                'inviter_id': str(inviter.id),
                'inviter_username': inviter.username,
                'message': f'Valid referral code from {inviter.username}'
            }
            
        except User.DoesNotExist:
            raise ServiceException(
                detail="Invalid referral code",
                code="invalid_referral_code"
            )
        except Exception as e:
            self.handle_service_error(e, "Failed to validate referral code")
    
    @transaction.atomic
    def create_referral(self, inviter: User, invitee: User, referral_code: str) -> Referral:
        """Create referral relationship"""
        try:
            # Check if referral already exists
            existing_referral = Referral.objects.filter(
                inviter=inviter,
                invitee=invitee
            ).first()
            
            if existing_referral:
                return existing_referral
            
            # Create referral
            referral = Referral.objects.create(
                inviter=inviter,
                invitee=invitee,
                referral_code=referral_code,
                expires_at=timezone.now() + timezone.timedelta(days=30)  # 30 days to complete
            )
            
            self.log_info(f"Referral created: {inviter.username} -> {invitee.username}")
            return referral
            
        except Exception as e:
            self.handle_service_error(e, "Failed to create referral")
    
    @transaction.atomic
    def complete_referral(self, referral_id: str, rental=None) -> Dict[str, Any]:
        """Complete referral after first rental"""
        try:
            referral = Referral.objects.get(id=referral_id)
            
            if referral.status != 'PENDING':
                raise ServiceException(
                    detail="Referral is not in pending status",
                    code="referral_not_pending"
                )
            
            if timezone.now() > referral.expires_at:
                referral.status = 'EXPIRED'
                referral.save(update_fields=['status'])
                raise ServiceException(
                    detail="Referral has expired",
                    code="referral_expired"
                )
            
            # Mark first rental as completed
            referral.first_rental_completed = True
            
            # Award points to both users using universal API
            from api.points.services.points_api import award_points
            from api.system.services import AppConfigService
            config_service = AppConfigService()
            
            inviter_points = int(config_service.get_config_cached('POINTS_REFERRAL_INVITER', 100))
            invitee_points = int(config_service.get_config_cached('POINTS_REFERRAL_INVITEE', 50))
            
            # Award points to inviter
            inviter_transaction = award_points(
                referral.inviter,
                inviter_points,
                'REFERRAL_INVITER',
                f'Referral reward for inviting {referral.invitee.username}',
                async_send=False,  # Immediate for referral completion
                referral_id=str(referral.id),
                invitee_username=referral.invitee.username
            )
            referral.inviter_points_awarded = inviter_points
            
            # Award points to invitee
            invitee_transaction = award_points(
                referral.invitee,
                invitee_points,
                'REFERRAL_INVITEE',
                f'Referral reward from {referral.inviter.username}',
                async_send=False,  # Immediate for referral completion
                referral_id=str(referral.id),
                inviter_username=referral.inviter.username
            )
            referral.invitee_points_awarded = invitee_points
            
            # Mark referral as completed
            referral.status = 'COMPLETED'
            referral.completed_at = timezone.now()
            referral.save(update_fields=[
                'first_rental_completed', 'inviter_points_awarded',
                'invitee_points_awarded', 'status', 'completed_at'
            ])
            
            # Send notifications
            from api.notifications.tasks import send_referral_completion_notification
            send_referral_completion_notification.delay(referral.id)
            
            self.log_info(f"Referral completed: {referral.inviter.username} -> {referral.invitee.username}")
            
            return {
                'referral_id': str(referral.id),
                'inviter_points': referral.inviter_points_awarded,
                'invitee_points': referral.invitee_points_awarded,
                'completed_at': referral.completed_at
            }
            
        except Referral.DoesNotExist:
            raise ServiceException(
                detail="Referral not found",
                code="referral_not_found"
            )
        except Exception as e:
            self.handle_service_error(e, "Failed to complete referral")
    
    def get_user_referrals(self, user, page: int = 1, page_size: int = 20) -> Dict[str, Any]:
        """Get referrals sent by user - OPTIMIZED with select_related"""
        try:
            # Optimized query with select_related and ordering
            queryset = Referral.objects.filter(inviter=user).select_related('invitee').order_by('-created_at')
            return paginate_queryset(queryset, page, page_size)
        except Exception as e:
            self.handle_service_error(e, "Failed to get user referrals")
    
    def get_referral_analytics(self, date_range: tuple = None) -> Dict[str, Any]:
        """Get referral analytics"""
        try:
            queryset = Referral.objects.all()
            
            if date_range:
                queryset = queryset.filter(created_at__range=date_range)
            
            total_referrals = queryset.count()
            successful_referrals = queryset.filter(status='COMPLETED').count()
            pending_referrals = queryset.filter(status='PENDING').count()
            expired_referrals = queryset.filter(status='EXPIRED').count()
            
            conversion_rate = (successful_referrals / total_referrals * 100) if total_referrals > 0 else 0
            
            total_points_awarded = queryset.filter(status='COMPLETED').aggregate(
                total=Sum('inviter_points_awarded') + Sum('invitee_points_awarded')
            )['total'] or 0
            
            # Calculate average time to complete
            completed_referrals = queryset.filter(status='COMPLETED', completed_at__isnull=False)
            avg_completion_time = 0
            if completed_referrals.exists():
                total_days = sum(
                    (r.completed_at - r.created_at).days 
                    for r in completed_referrals
                )
                avg_completion_time = total_days / completed_referrals.count()
            
            # Top referrers
            top_referrers = User.objects.annotate(
                referral_count=Count('sent_referrals', filter=Q(sent_referrals__status='COMPLETED'))
            ).filter(referral_count__gt=0).order_by('-referral_count')[:10]
            
            top_referrers_data = [
                {
                    'user_id': str(user.id),
                    'username': user.username,
                    'referral_count': user.referral_count
                }
                for user in top_referrers
            ]
            
            return {
                'total_referrals': total_referrals,
                'successful_referrals': successful_referrals,
                'pending_referrals': pending_referrals,
                'expired_referrals': expired_referrals,
                'conversion_rate': round(conversion_rate, 2),
                'total_points_awarded': total_points_awarded,
                'average_time_to_complete': round(avg_completion_time, 1),
                'top_referrers': top_referrers_data,
                'monthly_breakdown': []  # Can be implemented if needed
            }
            
        except Exception as e:
            self.handle_service_error(e, "Failed to get referral analytics")
    
    def expire_old_referrals(self) -> int:
        """Expire old pending referrals"""
        try:
            expired_count = Referral.objects.filter(
                status='PENDING',
                expires_at__lt=timezone.now()
            ).update(status='EXPIRED')
            
            self.log_info(f"Expired {expired_count} old referrals")
            return expired_count
            
        except Exception as e:
            self.handle_service_error(e, "Failed to expire old referrals")
