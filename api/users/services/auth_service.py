"""
Service for authentication operations
============================================================

This module contains service classes for service for authentication operations.

Auto-generated by Service Separator
Date: 2025-10-18 22:53:34
"""
from __future__ import annotations
import uuid
import logging
from typing import Dict, Any
from django.db import transaction
from django.utils import timezone
from django.core.cache import cache
from rest_framework_simplejwt.tokens import RefreshToken
from api.common.services.base import BaseService, ServiceException
from api.common.utils.helpers import (
    generate_random_code, 
    generate_unique_code,
    get_client_ip
)
from api.users.models import User, UserProfile, UserPoints, UserAuditLog
from api.payments.models import Wallet
from api.notifications.services import notify

logger = logging.getLogger(__name__)

class AuthService(BaseService):
    """Service for authentication operations"""
    
    def __init__(self):
        super().__init__()
        self.otp_expiry_minutes = 5
        self.max_otp_attempts = 3
    
    def _check_user_exists(self, identifier: str) -> bool:
        """Check if user exists by identifier"""
        if '@' in identifier:
            return User.objects.filter(email=identifier).exists()
        else:
            return User.objects.filter(phone_number=identifier).exists()
    

    
    def generate_otp(self, identifier: str) -> Dict[str, Any]:
        """Generate and send OTP - automatically detects login vs register"""
        try:
            # Auto-detect purpose based on user existence
            user_exists = self._check_user_exists(identifier)
            purpose = 'LOGIN' if user_exists else 'REGISTER'
            
            # Generate 6-digit OTP
            otp = generate_random_code(6, include_letters=False, include_numbers=True)
            
            # Create unified cache key
            cache_key = f"unified_otp:{identifier}"
            otp_data = {
                'otp': otp,
                'purpose': purpose,
                'identifier': identifier
            }
            
            attempts_key = f"otp_attempts:{identifier}"
            
            # Check rate limiting
            attempts = cache.get(attempts_key, 0)
            if attempts >= self.max_otp_attempts:
                raise ServiceException(
                    detail="Too many OTP requests. Please try again later.",
                    code="rate_limit_exceeded",
                    user_message="You've made too many OTP requests. Please wait before trying again."
                )
            
            # Store OTP in cache
            cache.set(cache_key, otp_data, timeout=self.otp_expiry_minutes * 60)
            cache.set(attempts_key, attempts + 1, timeout=3600)  # 1 hour
            
            # Send OTP via universal OTP sender
            from api.notifications.services import send_otp
            
            # Send OTP asynchronously - handles both existing and non-existing users
            send_otp(
                identifier=identifier,
                otp=otp,
                purpose=purpose,
                expiry_minutes=self.otp_expiry_minutes,
                async_send=True
            )
            
            self.log_info(f"OTP generated for {identifier} - Purpose: {purpose}")
            
            return {
                'message': f'OTP sent successfully for {purpose.lower()}',
                'purpose': purpose,
                'expires_in_minutes': self.otp_expiry_minutes,
                'identifier': identifier
            }
            
        except ServiceException:
            raise
        except Exception as e:
            raise ServiceException(
                detail="Failed to send OTP",
                code="otp_send_failed",
                context={'identifier': identifier, 'error': str(e)},
                user_message="Unable to send OTP. Please try again."
            )
    
    def verify_otp(self, identifier: str, otp: str) -> Dict[str, Any]:
        """Verify OTP and return verification token"""
        try:
            # Check unified cache key
            cache_key = f"unified_otp:{identifier}"
            otp_data = cache.get(cache_key)
            
            if not otp_data:
                raise ServiceException(
                    detail="OTP expired or not found",
                    code="otp_expired",
                    user_message="OTP has expired. Please request a new one."
                )
            
            # Verify OTP
            if otp_data['otp'] != otp:
                raise ServiceException(
                    detail="Invalid OTP",
                    code="invalid_otp",
                    user_message="The OTP you entered is incorrect. Please try again."
                )
            
            purpose = otp_data['purpose']
            
            # Generate verification token
            verification_token = str(uuid.uuid4())
            
            # Store verification token
            token_key = f"unified_verification:{verification_token}"
            token_data = {
                'identifier': identifier,
                'purpose': purpose,
                'verified_at': timezone.now().isoformat()
            }
            cache.set(token_key, token_data, timeout=600)  # 10 minutes
            
            # Clear OTP from cache
            cache.delete(cache_key)
            
            self.log_info(f"OTP verified for {identifier} - Purpose: {purpose}")
            
            return {
                'verification_token': verification_token,
                'message': 'OTP verified successfully',
                'purpose': purpose,
                'identifier': identifier,
                'expires_in_minutes': 10
            }
            
        except ServiceException:
            raise
        except Exception as e:
            raise ServiceException(
                detail="Failed to verify OTP",
                code="otp_verification_failed",
                context={'identifier': identifier, 'error': str(e)},
                user_message="Unable to verify OTP. Please try again."
            )
    
    def validate_verification_token(self, identifier: str, token: str) -> bool:
        """Validate verification token"""
        token_key = f"unified_verification:{token}"
        token_data = cache.get(token_key)
        return token_data and token_data['identifier'] == identifier
    
    def complete_auth(self, identifier: str, verification_token: str, username: str = None, request=None) -> Dict[str, Any]:
        """NEW: Unified authentication completion - handles both login and registration"""
        try:
            # Get verification data from unified token
            token_key = f"unified_verification:{verification_token}"
            token_data = cache.get(token_key)
            
            if not token_data:
                raise ServiceException(
                    detail="Verification token expired or invalid",
                    code="verification_token_expired",
                    user_message="Verification session has expired. Please start over."
                )
            
            # Validate identifier matches
            if token_data['identifier'] != identifier:
                raise ServiceException(
                    detail="Identifier mismatch",
                    code="identifier_mismatch",
                    user_message="Invalid verification session. Please start over."
                )
            
            purpose = token_data['purpose']
            
            if purpose == 'REGISTER':
                return self._handle_unified_registration(identifier, username, verification_token, request)
            else:  # LOGIN
                return self._handle_unified_login(identifier, verification_token, request)
                
        except ServiceException:
            raise
        except Exception as e:
            raise ServiceException(
                detail="Authentication failed",
                code="auth_failed",
                context={'identifier': identifier, 'error': str(e)},
                user_message="Authentication failed. Please try again."
            )
    
    @transaction.atomic
    def _handle_unified_registration(self, identifier: str, username: str, verification_token: str, request=None) -> Dict[str, Any]:
        """Handle unified registration"""
        if not username:
            raise ServiceException(
                detail="Username is required for registration",
                code="username_required",
                user_message="Please provide a username to complete registration."
            )
        
        # Check if user already exists (double-check)
        if self._check_user_exists(identifier):
            raise ServiceException(
                detail="User already exists",
                code="user_already_exists",
                user_message="An account with this identifier already exists. Please login instead."
            )
        
        # Create user data
        is_email = '@' in identifier
        user_data = {
            'username': username,
        }
        
        if is_email:
            user_data['email'] = identifier
        else:
            user_data['phone_number'] = identifier
        
        # Create user
        user = User.objects.create_user(**user_data)
        
        # Set verification status
        if is_email:
            user.email_verified = True
        else:
            user.phone_verified = True
        
        # Generate referral code
        user.referral_code = generate_unique_code("REF", 6)
        user.save()
        
        # Create related objects
        UserProfile.objects.create(user=user)
        UserPoints.objects.create(user=user)
        Wallet.objects.create(user=user)
        
        # Award signup points (after transaction commits)
        from api.points.services import award_points
        from api.system.services import AppConfigService
        
        config_service = AppConfigService()
        signup_points = int(config_service.get_config_cached('POINTS_SIGNUP', 50))
        
        transaction.on_commit(
            lambda: award_points(user, signup_points, 'SIGNUP', 'New user signup bonus', async_send=True)
        )
        
        # Log audit
        if request:
            self._log_user_audit(user, 'CREATE', 'USER', str(user.id), request)
        
        # Generate tokens
        refresh = RefreshToken.for_user(user)
        
        # Clear verification token
        token_key = f"unified_verification:{verification_token}"
        cache.delete(token_key)
        
        self.log_info(f"User registered successfully via unified auth: {user.username} ({identifier})")
        
        return {
            'message': 'Registration successful',
            'user': {
                'id': str(user.id),
                'username': user.username,
                'email': user.email,
                'phone_number': user.phone_number,
                'is_active': user.is_active
            },
            'tokens': {
                'access': str(refresh.access_token),
                'refresh': str(refresh)
            }
        }
    
    def _handle_unified_login(self, identifier: str, verification_token: str, request=None) -> Dict[str, Any]:
        """Handle unified login"""
        # Get user
        try:
            if '@' in identifier:
                user = User.objects.get(email=identifier)
            else:
                user = User.objects.get(phone_number=identifier)
        except User.DoesNotExist:
            raise ServiceException(
                detail="User not found",
                code="user_not_found",
                user_message="No account found with this identifier. Please register first."
            )
        
        # Check if user is active
        if not user.is_active:
            raise ServiceException(
                detail="Account is deactivated",
                code="account_deactivated",
                user_message="Your account has been deactivated. Please contact support."
            )
        
        # Update last login
        user.last_login = timezone.now()
        user.save(update_fields=['last_login'])
        
        # Generate tokens
        refresh = RefreshToken.for_user(user)
        
        # Log audit
        if request:
            self._log_user_audit(user, 'LOGIN', 'USER', str(user.id), request)
        
        # Clear verification token
        token_key = f"unified_verification:{verification_token}"
        cache.delete(token_key)
        
        self.log_info(f"User logged in successfully via unified auth: {user.username} ({identifier})")
        
        return {
            'message': 'Login successful',
            'user': {
                'id': str(user.id),
                'username': user.username,
                'email': user.email,
                'phone_number': user.phone_number,
                'is_active': user.is_active
            },
            'tokens': {
                'access': str(refresh.access_token),
                'refresh': str(refresh)
            }
        }
    

    
    def logout_user(self, refresh_token: str, user: User, request=None) -> Dict[str, Any]:
        """Enhanced logout user with comprehensive validation and error handling"""
        try:
            from rest_framework_simplejwt.tokens import RefreshToken
            from rest_framework_simplejwt.exceptions import TokenError, InvalidToken
            from django.utils import timezone
            
            # Validate and parse the refresh token
            token = RefreshToken(refresh_token)
            
            # Verify token belongs to the authenticated user
            token_user_id = token.payload.get('user_id')
            if str(token_user_id) != str(user.id):
                raise ServiceException(
                    detail="Token does not belong to authenticated user",
                    code="token_user_mismatch",
                    user_message="Invalid token for this user session."
                )
            
            # Blacklist the refresh token to prevent reuse
            token.blacklist()
            
            # Log successful logout with audit trail
            self._log_user_audit(
                user=user,
                action='LOGOUT',
                entity_type='AUTH',
                entity_id=str(user.id),
                request=request,
                additional_data={'token_blacklisted': True, 'method': 'manual_logout'}
            )
            
            logger.info(f"User logged out successfully: {user.username}")
            
            return {
                'message': 'Logout successful',
                'user_id': str(user.id),
                'logged_out_at': timezone.now().isoformat()
            }
            
        except TokenError as e:
            raise ServiceException(
                detail=f"Token error during logout: {str(e)}",
                code="invalid_refresh_token",
                context={'token_error': str(e)},
                user_message="Invalid refresh token. You may already be logged out."
            )
        
        except InvalidToken as e:
            raise ServiceException(
                detail=f"Invalid token format: {str(e)}",
                code="invalid_refresh_token",
                context={'invalid_token': str(e)},
                user_message="Invalid refresh token format. You may already be logged out."
            )
        
        except Exception as e:
            # Handle any other unexpected errors
            logger.error(f"Unexpected error during logout for user {user.id}: {str(e)}")
            raise ServiceException(
                detail=f"Unexpected logout error: {str(e)}",
                code="logout_failed",
                context={'error': str(e)},
                user_message="Logout failed due to an unexpected error. Please try again."
            )
    
    def refresh_token(self, refresh_token: str, request=None) -> Dict[str, Any]:
        """Enhanced token refresh with comprehensive validation and error handling"""
        try:
            from rest_framework_simplejwt.tokens import RefreshToken
            from rest_framework_simplejwt.exceptions import TokenError, InvalidToken
            
            # Validate and refresh the token
            refresh = RefreshToken(refresh_token)
            
            # Get user from token
            user_id = refresh.payload.get('user_id')
            if not user_id:
                raise ServiceException(
                    detail="Invalid refresh token - no user ID",
                    code="invalid_refresh_token",
                    user_message="Invalid refresh token. Please login again."
                )
            
            # Verify user still exists and is active
            try:
                user = User.objects.get(id=user_id, is_active=True)
            except User.DoesNotExist:
                raise ServiceException(
                    detail="User not found or inactive",
                    code="user_not_found",
                    user_message="User account not found or deactivated. Please login again."
                )
            
            # Generate new access token
            new_access_token = str(refresh.access_token)
            
            # Log successful token refresh with audit trail
            self._log_user_audit(
                user=user,
                action='TOKEN_REFRESH',
                entity_type='AUTH',
                entity_id=str(user.id),
                request=request,
                additional_data={'token_refreshed': True, 'method': 'refresh_endpoint'}
            )
            
            logger.info(f"Token refreshed successfully for user: {user.username}")
            
            return {
                'access': new_access_token,
                'refresh': str(refresh),  # Return the same refresh token
                'user': {
                    'id': str(user.id),
                    'username': user.username,
                    'email': user.email,
                    'is_active': user.is_active
                },
                'expires_in': 3600,  # 1 hour (adjust based on your JWT settings)
                'token_type': 'Bearer'
            }
            
        except TokenError as e:
            # Handle specific token errors including blacklisted tokens
            error_message = str(e)
            if "blacklisted" in error_message.lower():
                user_message = "This session has been logged out. Please login again."
                detail = f"Token is blacklisted: {error_message}"
            else:
                user_message = "Invalid or expired refresh token. Please login again."
                detail = f"Token error: {error_message}"
                
            raise ServiceException(
                detail=detail,
                code="invalid_refresh_token",
                context={'token_error': error_message},
                user_message=user_message
            )
        
        except InvalidToken as e:
            raise ServiceException(
                detail=f"Invalid token: {str(e)}",
                code="invalid_refresh_token", 
                context={'invalid_token': str(e)},
                user_message="Invalid refresh token format. Please login again."
            )
        
        except Exception as e:
            # Handle any other unexpected errors
            logger.error(f"Unexpected error during token refresh: {str(e)}")
            raise ServiceException(
                detail=f"Unexpected token refresh error: {str(e)}",
                code="token_refresh_failed",
                context={'error': str(e)},
                user_message="Token refresh failed due to an unexpected error. Please try again."
            )
    
    def _process_referral(self, user: User, referral_code: str) -> None:
        """Process referral code"""
        try:
            referrer = User.objects.get(referral_code=referral_code)
            user.referred_by = referrer
            user.save(update_fields=['referred_by'])
            
            # Award referral points (will be handled by Celery task after first rental)
            from api.points.services import complete_referral
            complete_referral(user, referrer, async_send=True)
            
        except User.DoesNotExist:
            # Invalid referral code - log but don't fail registration
            self.log_warning(f"Invalid referral code used: {referral_code}")
    
    def _log_user_audit(self, user: User, action: str, entity_type: str, entity_id: str, request, additional_data: Dict[str, Any] = None) -> None:
        """Log user audit trail"""
        try:
            # Include social auth context in audit data
            audit_data = {
                'social_provider': user.social_provider,
                'authentication_method': user.social_provider
            }
            if additional_data:
                audit_data.update(additional_data)
            
            UserAuditLog.objects.create(
                user=user,
                action=action,
                entity_type=entity_type,
                entity_id=entity_id,
                ip_address=get_client_ip(request),
                user_agent=request.META.get('HTTP_USER_AGENT', ''),
                session_id=request.session.session_key,
                new_values=audit_data
            )
        except Exception as e:
            self.log_error(f"Failed to log audit: {str(e)}")
    
    def update_account_status(self, user: User, new_status: str, reason: str = None) -> bool:
        """Update user account status and send notification"""
        try:
            old_status = user.status
            user.status = new_status
            user.save(update_fields=['status'])
            
            # Send account status notification
            notify(
                user,
                'account_status_changed',
                async_send=True,
                new_status=new_status,
                reason=reason
            )
            
            self.log_info(f"Account status updated: {user.username} {old_status} -> {new_status}")
            return True
            
        except Exception as e:
            self.log_error(f"Failed to update account status: {str(e)}")
            return False
    
    @transaction.atomic
    def create_social_user(self, social_data: Dict[str, Any], provider: str) -> User:
        """Create user from social authentication data"""
        try:
            # Extract user data from social provider
            email = social_data.get('email')
            name = social_data.get('name', '')
            picture = social_data.get('picture', '')
            provider_id = social_data.get('id') or social_data.get('sub')
            
            # Check if user already exists by email (prevent duplicate constraint violation)
            if email:
                try:
                    existing_user = User.objects.get(email=email)
                    self.log_info(f"User with email {email} already exists, linking social account")
                    return self.link_social_account(existing_user, social_data, provider)
                except User.DoesNotExist:
                    pass  # User doesn't exist, proceed with creation
            
            # Create user with unique username
            base_username = email.split('@')[0] if email else f"{provider}_{provider_id}"
            username = base_username
            counter = 1
            
            # Ensure username uniqueness
            while User.objects.filter(username=username).exists():
                username = f"{base_username}_{counter}"
                counter += 1
            
            try:
                user = User.objects.create_user(
                    email=email,
                    username=username,
                )
            except Exception as create_error:
                # Handle duplicate email constraint violation as fallback
                if 'duplicate key value violates unique constraint' in str(create_error) and 'email' in str(create_error):
                    self.log_warning(f"Duplicate email constraint during user creation, finding existing user: {email}")
                    if email:
                        existing_user = User.objects.get(email=email)
                        return self.link_social_account(existing_user, social_data, provider)
                raise create_error
            
            # Set social auth fields
            user.profile_picture = picture
            user.email_verified = True  # Social providers verify email
            user.social_provider = provider.upper()
            user.social_profile_data = social_data
            setattr(user, f'{provider}_id', provider_id)
            
            # Generate referral code
            user.referral_code = generate_unique_code("REF", 6)
            user.save()
            
            # Create related objects
            UserProfile.objects.create(
                user=user,
                full_name=name,
                avatar_url=picture
            )
            UserPoints.objects.create(user=user)
            Wallet.objects.create(user=user)
            
            # Award signup points (after transaction commits)
            from api.points.services import award_points
            from django.db import transaction
            
            # Schedule task after transaction commits to ensure user exists
            transaction.on_commit(
                lambda: award_points(user, 50, 'SOCIAL_SIGNUP', f'New user signup via {provider}', async_send=True)
            )
            
            # Send welcome message (after transaction commits)
            from api.users.tasks import send_social_auth_welcome_message
            transaction.on_commit(
                lambda: send_social_auth_welcome_message.delay(user.id, provider)
            )
            
            # Mark user as created via service to avoid duplicate processing
            user._created_via_service = True
            
            self.log_info(f"Social user created successfully: {user.username} via {provider}")
            
            return user
            
        except Exception as e:
            self.handle_service_error(e, f"Failed to create social user via {provider}")
    
    def link_social_account(self, user: User, social_data: Dict[str, Any], provider: str) -> User:
        """Link social account to existing user"""
        try:
            provider_id = social_data.get('id') or social_data.get('sub')
            
            # Update user with social data if not already linked
            provider_id_field = f'{provider}_id'
            current_provider_id = getattr(user, provider_id_field, None)
            
            if not current_provider_id:
                setattr(user, provider_id_field, provider_id)
                user.social_provider = provider.upper()
                user.social_profile_data = social_data
                
                # Update profile picture if not set
                if not user.profile_picture and social_data.get('picture'):
                    user.profile_picture = social_data.get('picture')
                
                user.save()
            
            # Ensure related objects exist and update profile with social data
            try:
                profile = user.profile
                if not profile.full_name and social_data.get('name'):
                    profile.full_name = social_data.get('name')
                if not profile.avatar_url and social_data.get('picture'):
                    profile.avatar_url = social_data.get('picture')
                profile.save()
            except UserProfile.DoesNotExist:
                UserProfile.objects.create(
                    user=user,
                    full_name=social_data.get('name', ''),
                    avatar_url=social_data.get('picture', '')
                )
            
            # Ensure other related objects exist
            UserPoints.objects.get_or_create(user=user)
            Wallet.objects.get_or_create(user=user)
            
            self.log_info(f"Social account linked: {user.username} with {provider}")
            
            return user
            
        except Exception as e:
            self.handle_service_error(e, f"Failed to link social account via {provider}")
