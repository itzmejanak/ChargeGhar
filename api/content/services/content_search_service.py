"""
Service for content search
============================================================

This module contains service classes for service for content search.

Auto-generated by Service Separator
Date: 2025-10-18 23:29:38
"""
from __future__ import annotations

from typing import Dict, Any, List
from django.db.models import Q
from api.common.services.base import BaseService
from api.content.models import ContentPage, FAQ, ContactInfo

class ContentSearchService(BaseService):
    """Service for content search"""
    
    def search_content(self, query: str, content_type: str = 'all') -> List[Dict[str, Any]]:
        """Search across all content types"""
        try:
            results = []
            
            if content_type in ['all', 'pages']:
                # Search content pages
                pages = ContentPage.objects.filter(
                    Q(title__icontains=query) | Q(content__icontains=query),
                    is_active=True
                )
                
                for page in pages:
                    results.append({
                        'content_type': 'page',
                        'title': page.title,
                        'excerpt': page.content[:200] + '...' if len(page.content) > 200 else page.content,
                        'url': f'/content/{page.page_type}',
                        'relevance_score': self._calculate_relevance(query, page.title, page.content)
                    })
            
            if content_type in ['all', 'faqs']:
                # Search FAQs
                faqs = FAQ.objects.filter(
                    Q(question__icontains=query) | Q(answer__icontains=query),
                    is_active=True
                )
                
                for faq in faqs:
                    results.append({
                        'content_type': 'faq',
                        'title': faq.question,
                        'excerpt': faq.answer[:200] + '...' if len(faq.answer) > 200 else faq.answer,
                        'url': f'/faq#{faq.id}',
                        'relevance_score': self._calculate_relevance(query, faq.question, faq.answer)
                    })
            
            if content_type in ['all', 'contact']:
                # Search contact info
                contact_info = ContactInfo.objects.filter(
                    Q(label__icontains=query) | Q(value__icontains=query) | Q(description__icontains=query),
                    is_active=True
                )
                
                for info in contact_info:
                    results.append({
                        'content_type': 'contact',
                        'title': info.label,
                        'excerpt': f"{info.value} - {info.description or ''}",
                        'url': '/contact',
                        'relevance_score': self._calculate_relevance(query, info.label, info.value)
                    })
            
            # Sort by relevance score
            results.sort(key=lambda x: x['relevance_score'], reverse=True)
            
            return results[:20]  # Limit to top 20 results
            
        except Exception as e:
            self.handle_service_error(e, "Failed to search content")
    
    def _calculate_relevance(self, query: str, title: str, content: str) -> float:
        """Calculate relevance score for search results"""
        try:
            query_lower = query.lower()
            title_lower = title.lower()
            content_lower = content.lower()
            
            score = 0.0
            
            # Title matches get higher score
            if query_lower in title_lower:
                score += 10.0
                if title_lower.startswith(query_lower):
                    score += 5.0
            
            # Content matches
            content_matches = content_lower.count(query_lower)
            score += content_matches * 2.0
            
            # Exact matches get bonus
            if query_lower == title_lower:
                score += 20.0
            
            return score
            
        except Exception:
            return 0.0
