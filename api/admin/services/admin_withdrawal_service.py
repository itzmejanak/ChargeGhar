"""
Service for admin withdrawal management
============================================================

This module contains service classes for admin withdrawal management operations.
Delegates core withdrawal logic to the payments WithdrawalService for consistency.

Auto-generated by Service Separator
Date: 2025-10-22 02:05:00
"""
from __future__ import annotations
from typing import Dict, Any
from django.db import transaction
from api.common.services.base import CRUDService, ServiceException
from api.admin.models import AdminActionLog
from api.payments.models import WithdrawalRequest
from api.payments.services.withdrawal import WithdrawalService

class AdminWithdrawalService(CRUDService):
    """Service for admin withdrawal management - delegates to core WithdrawalService"""
    model = WithdrawalRequest
    
    def __init__(self):
        super().__init__()
        self.withdrawal_service = WithdrawalService()
    
    def get_pending_withdrawals(self, filters: Dict[str, Any] = None) -> Dict[str, Any]:
        """Get pending withdrawal requests - delegates to core service"""
        return self.withdrawal_service.get_pending_withdrawals(filters)
    
    @transaction.atomic
    def process_withdrawal(self, withdrawal_id: str, action: str, admin_notes: str, admin_user) -> WithdrawalRequest:
        """Process withdrawal request (approve/reject) - uses core service with admin logging"""
        try:
            # Validate action
            if action not in ['APPROVE', 'REJECT']:
                raise ServiceException(
                    detail="Invalid action. Must be 'APPROVE' or 'REJECT'",
                    code="invalid_action"
                )
            
            # Delegate to core service
            if action == 'APPROVE':
                withdrawal = self.withdrawal_service.approve_withdrawal(withdrawal_id, admin_user, admin_notes)
            else:  # REJECT
                withdrawal = self.withdrawal_service.reject_withdrawal(withdrawal_id, admin_user, admin_notes)
            
            # Log admin action
            self._log_admin_action(withdrawal, action, admin_notes, admin_user)
            
            # Send notification using clean API
            self._send_withdrawal_notification(withdrawal, action, admin_notes)
            
            return withdrawal
            
        except ServiceException:
            # Re-raise service exceptions from core service
            raise
        except Exception as e:
            self.handle_service_error(e, "Failed to process withdrawal")

    def _log_admin_action(self, withdrawal: WithdrawalRequest, action: str, admin_notes: str, admin_user) -> None:
        """Log admin action for audit trail"""
        try:
            AdminActionLog.objects.create(
                admin_user=admin_user,
                action_type=f'WITHDRAWAL_{action}',
                target_model='WithdrawalRequest',
                target_id=str(withdrawal.id),
                changes={
                    'action': action,
                    'amount': str(withdrawal.amount),
                    'net_amount': str(withdrawal.net_amount),
                    'processing_fee': str(withdrawal.processing_fee),
                    'internal_reference': withdrawal.internal_reference,
                    'payment_method': withdrawal.payment_method.name,
                    'admin_notes': admin_notes
                },
                description=f"Withdrawal {action.lower()}ed",
                ip_address="127.0.0.1",  # TODO: Get actual IP from request
                user_agent="Admin Panel"  # TODO: Get actual user agent from request
            )
        except Exception as e:
            self.log_warning(f"Failed to log admin action: {str(e)}")

    def _send_withdrawal_notification(self, withdrawal: WithdrawalRequest, action: str, admin_notes: str) -> None:
        """Send withdrawal notification to user"""
        try:
            from api.notifications.services import notify
            template_slug = 'withdrawal_approved' if action == 'APPROVE' else 'withdrawal_rejected'
            notify(
                withdrawal.user, 
                template_slug, 
                amount=float(withdrawal.amount),
                net_amount=float(withdrawal.net_amount),
                processing_fee=float(withdrawal.processing_fee),
                withdrawal_reference=withdrawal.internal_reference,
                admin_notes=admin_notes
            )
        except Exception as e:
            self.log_warning(f"Failed to send withdrawal notification: {str(e)}")

    def get_withdrawal_details(self, withdrawal_id: str) -> WithdrawalRequest:
        """Get detailed withdrawal information"""
        return self.withdrawal_service.get_withdrawal_by_id(withdrawal_id)

    def get_withdrawals_by_status(self, status: str, page: int = 1, page_size: int = 20) -> Dict[str, Any]:
        """Get withdrawals by status"""
        return self.withdrawal_service.get_withdrawals_by_status(status, page, page_size)

    def get_withdrawal_analytics(self) -> Dict[str, Any]:
        """Get withdrawal analytics for admin dashboard"""
        try:
            from django.db.models import Count, Sum
            from datetime import datetime, timedelta
            
            # Get analytics data
            total_withdrawals = WithdrawalRequest.objects.count()
            pending_withdrawals = WithdrawalRequest.objects.filter(status='REQUESTED').count()
            completed_withdrawals = WithdrawalRequest.objects.filter(status='COMPLETED').count()
            rejected_withdrawals = WithdrawalRequest.objects.filter(status='REJECTED').count()
            
            # Today's withdrawals
            today = datetime.now().date()
            today_withdrawals = WithdrawalRequest.objects.filter(
                requested_at__date=today
            ).aggregate(
                count=Count('id'),
                total_amount=Sum('amount')
            )
            
            # This month's withdrawals
            month_start = today.replace(day=1)
            month_withdrawals = WithdrawalRequest.objects.filter(
                requested_at__date__gte=month_start
            ).aggregate(
                count=Count('id'),
                total_amount=Sum('amount')
            )
            
            return {
                'total_withdrawals': total_withdrawals,
                'pending_withdrawals': pending_withdrawals,
                'completed_withdrawals': completed_withdrawals,
                'rejected_withdrawals': rejected_withdrawals,
                'today_withdrawals': {
                    'count': today_withdrawals['count'] or 0,
                    'total_amount': float(today_withdrawals['total_amount'] or 0)
                },
                'month_withdrawals': {
                    'count': month_withdrawals['count'] or 0,
                    'total_amount': float(month_withdrawals['total_amount'] or 0)
                }
            }
            
        except Exception as e:
            self.log_error(f"Error getting withdrawal analytics: {str(e)}")
            return {
                'total_withdrawals': 0,
                'pending_withdrawals': 0,
                'completed_withdrawals': 0,
                'rejected_withdrawals': 0,
                'today_withdrawals': {'count': 0, 'total_amount': 0},
                'month_withdrawals': {'count': 0, 'total_amount': 0}
            }