"""
Service for admin user management
============================================================

This module contains service classes for service for admin user management.

Auto-generated by Service Separator
Date: 2025-10-18 23:39:20
"""
from __future__ import annotations
from typing import Dict, Any
from decimal import Decimal
from django.db import transaction
from django.db.models import Q
from api.common.services.base import CRUDService, ServiceException
from api.common.utils.helpers import paginate_queryset
from api.admin.models import AdminActionLog
from api.users.models import User

class AdminUserService(CRUDService):
    """Service for admin user management"""
    model = User
    
    def get_users_list(self, filters: Dict[str, Any] = None) -> Dict[str, Any]:
        """Get paginated list of users with filters"""
        try:
            queryset = User.objects.select_related('profile', 'kyc', 'wallet', 'points')
            
            # Apply filters
            if filters:
                if filters.get('status'):
                    queryset = queryset.filter(status=filters['status'])
                
                if filters.get('search'):
                    search_term = filters['search']
                    queryset = queryset.filter(
                        Q(username__icontains=search_term) |
                        Q(email__icontains=search_term) |
                        Q(phone_number__icontains=search_term)
                    )
                
                if filters.get('start_date'):
                    queryset = queryset.filter(date_joined__gte=filters['start_date'])
                
                if filters.get('end_date'):
                    queryset = queryset.filter(date_joined__lte=filters['end_date'])
            
            # Order by latest first
            queryset = queryset.order_by('-date_joined')
            
            # Pagination
            page = filters.get('page', 1) if filters else 1
            page_size = filters.get('page_size', 20) if filters else 20
            
            return paginate_queryset(queryset, page, page_size)
            
        except Exception as e:
            self.handle_service_error(e, "Failed to get users list")
    
    def get_user_detail(self, user_id: str) -> User:
        """Get detailed user information"""
        try:
            return User.objects.select_related(
                'profile', 'kyc', 'wallet', 'points'
            ).prefetch_related(
                'rentals', 'sent_referrals', 'received_referrals'
            ).get(id=user_id)
        except User.DoesNotExist:
            raise ServiceException(
                detail="User not found",
                code="user_not_found"
            )
        except Exception as e:
            self.handle_service_error(e, "Failed to get user detail")
    
    @transaction.atomic
    def update_user_status(self, user_id: str, status: str, reason: str, admin_user) -> User:
        """Update user status"""
        try:
            user = User.objects.get(id=user_id)
            old_status = user.status
            
            user.status = status
            user.save(update_fields=['status'])
            
            # Log admin action
            self._log_admin_action(
                admin_user=admin_user,
                action_type='UPDATE_USER_STATUS',
                target_model='User',
                target_id=str(user.id),
                changes={
                    'old_status': old_status,
                    'new_status': status,
                    'reason': reason
                },
                description=f"Updated user status from {old_status} to {status}"
            )
            
            # Send notification to user if status changed to banned/inactive
            if status in ['BANNED', 'INACTIVE']:
                from api.notifications.services import notify
                notify(
                    user,
                    'account_status_update',
                    async_send=True,
                    status=status,
                    reason=reason
                )
            
            self.log_info(f"User status updated: {user.username} -> {status}")
            return user
            
        except User.DoesNotExist:
            raise ServiceException(
                detail="User not found",
                code="user_not_found"
            )
        except Exception as e:
            self.handle_service_error(e, "Failed to update user status")
    
    @transaction.atomic
    def add_user_balance(self, user_id: str, amount: Decimal, reason: str, admin_user) -> Dict[str, Any]:
        """Add balance to user wallet"""
        try:
            user = User.objects.get(id=user_id)
            
            # Get or create wallet
            from api.payments.services import WalletService
            wallet_service = WalletService()
            
            old_balance = wallet_service.get_wallet_balance(user)
            
            # Add balance
            wallet_transaction = wallet_service.add_balance(
                user=user,
                amount=amount,
                description=f"Admin adjustment: {reason}"
            )
            
            new_balance = wallet_service.get_wallet_balance(user)
            
            # Log admin action
            self._log_admin_action(
                admin_user=admin_user,
                action_type='ADD_USER_BALANCE',
                target_model='User',
                target_id=str(user.id),
                changes={
                    'old_balance': str(old_balance),
                    'new_balance': str(new_balance),
                    'amount_added': str(amount),
                    'reason': reason
                },
                description=f"Added NPR {amount} to user wallet"
            )
            
            # Send notification to user
            from api.notifications.services import notify
            notify(
                user,
                'wallet_recharged',
                async_send=True,
                amount=amount,
                new_balance=new_balance
            )
            
            self.log_info(f"Balance added to user: {user.username} +NPR {amount}")
            
            return {
                'old_balance': old_balance,
                'new_balance': new_balance,
                'amount_added': amount,
                'transaction_id': str(wallet_transaction.id)
            }
            
        except User.DoesNotExist:
            raise ServiceException(
                detail="User not found",
                code="user_not_found"
            )
        except Exception as e:
            self.handle_service_error(e, "Failed to add user balance")
    
    def get_kyc_submissions(self, filters: Dict[str, Any] = None) -> Dict[str, Any]:
        """Get paginated list of KYC submissions with filters"""
        try:
            from api.users.models import UserKYC
            
            queryset = UserKYC.objects.select_related('user', 'verified_by')
            
            # Apply filters
            if filters:
                if filters.get('status'):
                    queryset = queryset.filter(status=filters['status'])
                
                if filters.get('search'):
                    search_term = filters['search']
                    queryset = queryset.filter(
                        Q(user__username__icontains=search_term) |
                        Q(user__email__icontains=search_term) |
                        Q(document_number__icontains=search_term)
                    )
                
                if filters.get('start_date'):
                    queryset = queryset.filter(created_at__gte=filters['start_date'])
                
                if filters.get('end_date'):
                    queryset = queryset.filter(created_at__lte=filters['end_date'])
            
            # Order by latest pending first, then by creation date
            from django.db.models import Case, When, IntegerField
            queryset = queryset.annotate(
                pending_priority=Case(
                    When(status='PENDING', then=0),
                    default=1,
                    output_field=IntegerField()
                )
            ).order_by('pending_priority', '-created_at')
            
            # Pagination
            page = filters.get('page', 1) if filters else 1
            page_size = filters.get('page_size', 20) if filters else 20
            
            return paginate_queryset(queryset, page, page_size)
            
        except Exception as e:
            self.handle_service_error(e, "Failed to get KYC submissions")
    
    @transaction.atomic
    def update_kyc_status(self, kyc_id: str, status: str, rejection_reason: str, admin_user) -> Dict[str, Any]:
        """Approve or reject KYC submission"""
        try:
            from api.users.models import UserKYC
            from django.utils import timezone
            
            kyc = UserKYC.objects.select_related('user').get(id=kyc_id)
            old_status = kyc.status
            
            # Update KYC status
            kyc.status = status
            kyc.verified_by = admin_user
            
            if status == 'APPROVED':
                kyc.verified_at = timezone.now()
                kyc.rejection_reason = None
            elif status == 'REJECTED':
                kyc.rejection_reason = rejection_reason
                kyc.verified_at = None
            
            kyc.save()
            
            # Log admin action
            self._log_admin_action(
                admin_user=admin_user,
                action_type='UPDATE_KYC_STATUS',
                target_model='UserKYC',
                target_id=str(kyc.id),
                changes={
                    'old_status': old_status,
                    'new_status': status,
                    'rejection_reason': rejection_reason,
                    'user': kyc.user.username
                },
                description=f"Updated KYC status from {old_status} to {status} for user {kyc.user.username}"
            )
            
            # Send notification to user
            from api.notifications.services import notify
            notify(
                kyc.user,
                'kyc_status_update',
                async_send=True,
                kyc_status=status.lower(),
                rejection_reason=rejection_reason or ''
            )
            
            # Award KYC completion points if approved
            if status == 'APPROVED':
                from api.points.tasks import award_points_task
                from api.system.services import AppConfigService
                
                config_service = AppConfigService()
                kyc_points = int(config_service.get_config_cached('POINTS_KYC', 30))
                
                transaction.on_commit(
                    lambda: award_points_task.delay(
                        str(kyc.user.id),
                        kyc_points,
                        'KYC',
                        'KYC verification completed'
                    )
                )
            
            self.log_info(f"KYC status updated: {kyc.user.username} -> {status}")
            
            return {
                'kyc_id': str(kyc.id),
                'user': kyc.user.username,
                'old_status': old_status,
                'new_status': status,
                'verified_by': admin_user.username
            }
            
        except UserKYC.DoesNotExist:
            raise ServiceException(
                detail="KYC submission not found",
                code="kyc_not_found"
            )
        except Exception as e:
            self.handle_service_error(e, "Failed to update KYC status")
    
    def _log_admin_action(self, admin_user, action_type: str, target_model: str, 
                         target_id: str, changes: Dict[str, Any], description: str = "") -> None:
        """Log admin action for audit trail"""
        try:
            # This would be called from a request context to get IP and user agent
            # For now, we'll use placeholder values
            AdminActionLog.objects.create(
                admin_user=admin_user,
                action_type=action_type,
                target_model=target_model,
                target_id=target_id,
                changes=changes,
                description=description,
                ip_address="127.0.0.1",  # Should be passed from request
                user_agent="Admin Panel"  # Should be passed from request
            )
        except Exception as e:
            self.log_error(f"Failed to log admin action: {str(e)}")
