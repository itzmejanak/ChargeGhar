"""
Service for admin analytics
============================================================

This module contains service classes for service for admin analytics.

Auto-generated by Service Separator
Date: 2025-10-18 23:39:20
Updated: 2025-11-07 - Added rentals & revenue over time analytics
"""
from __future__ import annotations
from typing import Dict, Any, List
from decimal import Decimal
from datetime import datetime, timedelta, date
from django.utils import timezone
from django.db.models import Sum, Count, Q
from django.db.models.functions import TruncDate, TruncWeek, TruncMonth
from api.common.services.base import BaseService, ServiceException
from api.users.models import User
from api.stations.models import Station, StationIssue
from api.payments.models import Transaction
from api.rentals.models import Rental

class AdminAnalyticsService(BaseService):
    """Service for admin analytics"""
    
    def get_dashboard_analytics(self) -> Dict[str, Any]:
        """Get comprehensive dashboard analytics"""
        try:
            now = timezone.now()
            today_start = now.replace(hour=0, minute=0, second=0, microsecond=0)
            month_start = today_start.replace(day=1)
            
            # User metrics
            total_users = User.objects.count()
            active_users = User.objects.filter(status='ACTIVE').count()
            new_users_today = User.objects.filter(date_joined__gte=today_start).count()
            new_users_this_month = User.objects.filter(date_joined__gte=month_start).count()
            
            # Rental metrics
            total_rentals = Rental.objects.count()
            active_rentals = Rental.objects.filter(status__in=['ACTIVE', 'PENDING']).count()
            completed_rentals_today = Rental.objects.filter(
                status='COMPLETED',
                ended_at__gte=today_start
            ).count()
            overdue_rentals = Rental.objects.filter(status='OVERDUE').count()
            
            # Revenue metrics
            total_revenue = Transaction.objects.filter(
                status='SUCCESS'
            ).aggregate(total=Sum('amount'))['total'] or Decimal('0')
            
            revenue_today = Transaction.objects.filter(
                status='SUCCESS',
                created_at__gte=today_start
            ).aggregate(total=Sum('amount'))['total'] or Decimal('0')
            
            revenue_this_month = Transaction.objects.filter(
                status='SUCCESS',
                created_at__gte=month_start
            ).aggregate(total=Sum('amount'))['total'] or Decimal('0')
            
            # Station metrics
            total_stations = Station.objects.count()
            online_stations = Station.objects.filter(status='ONLINE').count()
            offline_stations = Station.objects.filter(status='OFFLINE').count()
            maintenance_stations = Station.objects.filter(is_maintenance=True).count()
            
            # System health
            system_health = self._get_system_health()
            
            # Recent issues
            recent_issues = list(StationIssue.objects.filter(
                created_at__gte=today_start,
                status__in=['REPORTED', 'ACKNOWLEDGED']
            ).select_related('station')[:5].values(
                'id', 'issue_type', 'station__station_name', 'created_at'
            ))
            
            return {
                'total_users': total_users,
                'active_users': active_users,
                'new_users_today': new_users_today,
                'new_users_this_month': new_users_this_month,
                'total_rentals': total_rentals,
                'active_rentals': active_rentals,
                'completed_rentals_today': completed_rentals_today,
                'overdue_rentals': overdue_rentals,
                'total_revenue': total_revenue,
                'revenue_today': revenue_today,
                'revenue_this_month': revenue_this_month,
                'total_stations': total_stations,
                'online_stations': online_stations,
                'offline_stations': offline_stations,
                'maintenance_stations': maintenance_stations,
                'system_health': system_health,
                'recent_issues': recent_issues
            }
            
        except Exception as e:
            self.handle_service_error(e, "Failed to get dashboard analytics")
    
    def _get_system_health(self) -> Dict[str, Any]:
        """Get system health metrics"""
        try:
            # Mock system health data
            return {
                'database': 'healthy',
                'redis': 'healthy',
                'celery': 'healthy',
                'storage': 'healthy',
                'response_time_avg': 150.5,
                'error_rate': 0.02,
                'uptime_percentage': 99.9
            }
        except Exception as e:
            self.log_error(f"Failed to get system health: {str(e)}")
            return {}
    
    # ============================================================
    # Analytics - Rentals Over Time
    # ============================================================
    
    def get_rentals_over_time(
        self,
        period: str = 'daily',
        start_date: date = None,
        end_date: date = None,
        status: str = None
    ) -> Dict[str, Any]:
        """
        Get rentals over time for chart visualization
        
        Args:
            period: Aggregation period ('daily', 'weekly', 'monthly')
            start_date: Start date for analysis (default: 30 days ago)
            end_date: End date for analysis (default: today)
            status: Optional filter by rental status
            
        Returns:
            Dict with chart data and summary statistics
        """
        try:
            # Set default dates if not provided
            if not end_date:
                end_date = timezone.now().date()
            if not start_date:
                start_date = end_date - timedelta(days=30)
            
            # Validate period
            if period not in ['daily', 'weekly', 'monthly']:
                raise ServiceException(
                    detail="Invalid period. Must be 'daily', 'weekly', or 'monthly'",
                    code="invalid_period"
                )
            
            # Validate date range
            if start_date > end_date:
                raise ServiceException(
                    detail="Start date must be before or equal to end date",
                    code="invalid_date_range"
                )
            
            # Build base queryset
            queryset = Rental.objects.filter(
                created_at__date__gte=start_date,
                created_at__date__lte=end_date
            )
            
            # Apply status filter if provided
            if status:
                queryset = queryset.filter(status=status)
            
            # Select truncation function based on period
            if period == 'daily':
                trunc_func = TruncDate('created_at')
            elif period == 'weekly':
                trunc_func = TruncWeek('created_at')
            else:  # monthly
                trunc_func = TruncMonth('created_at')
            
            # Aggregate data
            aggregated_data = queryset.annotate(
                period_date=trunc_func
            ).values('period_date').annotate(
                total=Count('id'),
                completed=Count('id', filter=Q(status='COMPLETED')),
                active=Count('id', filter=Q(status='ACTIVE')),
                pending=Count('id', filter=Q(status='PENDING')),
                cancelled=Count('id', filter=Q(status='CANCELLED')),
                overdue=Count('id', filter=Q(status='OVERDUE'))
            ).order_by('period_date')
            
            # Generate complete date range (fill gaps with zeros)
            date_range = self._generate_date_range(start_date, end_date, period)
            
            # Convert aggregated data to dict for easy lookup
            data_dict = {
                item['period_date'].date() if isinstance(item['period_date'], datetime) else item['period_date']: item
                for item in aggregated_data
            }
            
            # Build chart data
            chart_data = []
            total_rentals = 0
            peak_count = 0
            peak_date = None
            
            for date_point in date_range:
                data = data_dict.get(date_point, {})
                total = data.get('total', 0)
                total_rentals += total
                
                if total > peak_count:
                    peak_count = total
                    peak_date = date_point
                
                chart_data.append({
                    'date': date_point.isoformat(),
                    'label': self._format_period_label(date_point, period),
                    'total': total,
                    'completed': data.get('completed', 0),
                    'active': data.get('active', 0),
                    'pending': data.get('pending', 0),
                    'cancelled': data.get('cancelled', 0),
                    'overdue': data.get('overdue', 0)
                })
            
            # Calculate average
            avg_per_period = total_rentals / len(chart_data) if chart_data else 0
            
            return {
                'period': period,
                'start_date': start_date.isoformat(),
                'end_date': end_date.isoformat(),
                'total_rentals': total_rentals,
                'chart_data': chart_data,
                'summary': {
                    'avg_per_period': round(avg_per_period, 2),
                    'peak_date': peak_date.isoformat() if peak_date else None,
                    'peak_count': peak_count
                }
            }
            
        except ServiceException:
            raise
        except Exception as e:
            self.handle_service_error(e, "Failed to get rentals over time")
    
    # ============================================================
    # Analytics - Revenue Over Time
    # ============================================================
    
    def get_revenue_over_time(
        self,
        period: str = 'monthly',
        start_date: date = None,
        end_date: date = None,
        transaction_type: str = None
    ) -> Dict[str, Any]:
        """
        Get revenue over time for chart visualization
        
        Args:
            period: Aggregation period ('daily', 'weekly', 'monthly')
            start_date: Start date for analysis (default: 30 days ago)
            end_date: End date for analysis (default: today)
            transaction_type: Optional filter by transaction type
            
        Returns:
            Dict with chart data and summary statistics
        """
        try:
            # Set default dates if not provided
            if not end_date:
                end_date = timezone.now().date()
            if not start_date:
                # Default to 6 months ago for revenue
                start_date = end_date - timedelta(days=180)
            
            # Validate period
            if period not in ['daily', 'weekly', 'monthly']:
                raise ServiceException(
                    detail="Invalid period. Must be 'daily', 'weekly', or 'monthly'",
                    code="invalid_period"
                )
            
            # Validate date range
            if start_date > end_date:
                raise ServiceException(
                    detail="Start date must be before or equal to end date",
                    code="invalid_date_range"
                )
            
            # Build base queryset - only successful transactions
            queryset = Transaction.objects.filter(
                status='SUCCESS',
                created_at__date__gte=start_date,
                created_at__date__lte=end_date
            )
            
            # Apply transaction type filter if provided
            if transaction_type:
                queryset = queryset.filter(transaction_type=transaction_type)
            
            # Select truncation function based on period
            if period == 'daily':
                trunc_func = TruncDate('created_at')
            elif period == 'weekly':
                trunc_func = TruncWeek('created_at')
            else:  # monthly
                trunc_func = TruncMonth('created_at')
            
            # Aggregate data
            aggregated_data = queryset.annotate(
                period_date=trunc_func
            ).values('period_date').annotate(
                total_revenue=Sum('amount'),
                rental_revenue=Sum('amount', filter=Q(transaction_type='RENTAL')),
                rental_due_revenue=Sum('amount', filter=Q(transaction_type='RENTAL_DUE')),
                topup_revenue=Sum('amount', filter=Q(transaction_type='TOPUP')),
                fine_revenue=Sum('amount', filter=Q(transaction_type='FINE')),
                transaction_count=Count('id')
            ).order_by('period_date')
            
            # Generate complete date range (fill gaps with zeros)
            date_range = self._generate_date_range(start_date, end_date, period)
            
            # Convert aggregated data to dict for easy lookup
            data_dict = {
                item['period_date'].date() if isinstance(item['period_date'], datetime) else item['period_date']: item
                for item in aggregated_data
            }
            
            # Build chart data
            chart_data = []
            total_revenue = Decimal('0')
            peak_revenue = Decimal('0')
            peak_month = None
            previous_revenue = None
            
            for date_point in date_range:
                data = data_dict.get(date_point, {})
                period_revenue = data.get('total_revenue') or Decimal('0')
                total_revenue += period_revenue
                
                if period_revenue > peak_revenue:
                    peak_revenue = period_revenue
                    peak_month = date_point
                
                chart_data.append({
                    'date': date_point.isoformat(),
                    'label': self._format_period_label(date_point, period),
                    'total_revenue': float(period_revenue),
                    'rental_revenue': float(data.get('rental_revenue') or Decimal('0')),
                    'rental_due_revenue': float(data.get('rental_due_revenue') or Decimal('0')),
                    'topup_revenue': float(data.get('topup_revenue') or Decimal('0')),
                    'fine_revenue': float(data.get('fine_revenue') or Decimal('0')),
                    'transaction_count': data.get('transaction_count', 0)
                })
            
            # Calculate average and growth rate
            avg_per_period = total_revenue / len(chart_data) if chart_data else Decimal('0')
            
            # Calculate growth rate (comparing last period to previous)
            growth_rate = None
            if len(chart_data) >= 2:
                last_revenue = Decimal(str(chart_data[-1]['total_revenue']))
                previous_revenue = Decimal(str(chart_data[-2]['total_revenue']))
                if previous_revenue > 0:
                    growth_rate = float(((last_revenue - previous_revenue) / previous_revenue) * 100)
            
            return {
                'period': period,
                'start_date': start_date.isoformat(),
                'end_date': end_date.isoformat(),
                'currency': 'NPR',
                'total_revenue': float(total_revenue),
                'chart_data': chart_data,
                'summary': {
                    'avg_per_period': float(avg_per_period),
                    'peak_month': self._format_period_label(peak_month, period) if peak_month else None,
                    'peak_revenue': float(peak_revenue),
                    'growth_rate': round(growth_rate, 2) if growth_rate is not None else None
                }
            }
            
        except ServiceException:
            raise
        except Exception as e:
            self.handle_service_error(e, "Failed to get revenue over time")
    
    # ============================================================
    # Helper Methods
    # ============================================================
    
    def _generate_date_range(
        self,
        start_date: date,
        end_date: date,
        period: str
    ) -> List[date]:
        """
        Generate list of dates for the given period
        
        Args:
            start_date: Start date
            end_date: End date
            period: Period type ('daily', 'weekly', 'monthly')
            
        Returns:
            List of dates representing each period
        """
        date_list = []
        current_date = start_date
        
        if period == 'daily':
            while current_date <= end_date:
                date_list.append(current_date)
                current_date += timedelta(days=1)
        
        elif period == 'weekly':
            # Start from the beginning of the week
            current_date = start_date - timedelta(days=start_date.weekday())
            while current_date <= end_date:
                date_list.append(current_date)
                current_date += timedelta(weeks=1)
        
        elif period == 'monthly':
            # Start from the beginning of the month
            current_date = start_date.replace(day=1)
            while current_date <= end_date:
                date_list.append(current_date)
                # Move to next month
                if current_date.month == 12:
                    current_date = current_date.replace(year=current_date.year + 1, month=1)
                else:
                    current_date = current_date.replace(month=current_date.month + 1)
        
        return date_list
    
    def _format_period_label(self, date_point: date, period: str) -> str:
        """
        Format date label based on period type
        
        Args:
            date_point: Date to format
            period: Period type
            
        Returns:
            Formatted label string
        """
        if not date_point:
            return ""
        
        if period == 'daily':
            return date_point.strftime('%b %d, %Y')  # "Nov 07, 2025"
        elif period == 'weekly':
            # Show week start date
            return f"Week of {date_point.strftime('%b %d, %Y')}"
        else:  # monthly
            return date_point.strftime('%B %Y')  # "November 2025"

