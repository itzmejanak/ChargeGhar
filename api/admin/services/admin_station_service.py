"""
Service for admin station management
============================================================

This module contains service classes for service for admin station management.

Auto-generated by Service Separator
Date: 2025-10-18 23:39:20
"""
from __future__ import annotations
from typing import Dict, Any
from django.db import transaction
from django.utils import timezone
from django.db.models import Q
from api.common.services.base import CRUDService, ServiceException
from api.common.utils.helpers import paginate_queryset
from api.admin.models import AdminActionLog
from api.stations.models import Station

class AdminStationService(CRUDService):
    """Service for admin station management"""
    model = Station
    
    def get_stations_list(self, filters: Dict[str, Any] = None) -> Dict[str, Any]:
        """Get paginated list of stations with filters"""
        try:
            queryset = Station.objects.prefetch_related('slots', 'issues')
            
            # Apply filters
            if filters:
                if filters.get('status'):
                    queryset = queryset.filter(status=filters['status'])
                
                if filters.get('search'):
                    search_term = filters['search']
                    queryset = queryset.filter(
                        Q(station_name__icontains=search_term) |
                        Q(serial_number__icontains=search_term) |
                        Q(address__icontains=search_term)
                    )
                
                if filters.get('start_date'):
                    queryset = queryset.filter(created_at__gte=filters['start_date'])
                
                if filters.get('end_date'):
                    queryset = queryset.filter(created_at__lte=filters['end_date'])
            
            # Order by latest first
            queryset = queryset.order_by('-created_at')
            
            # Pagination
            page = filters.get('page', 1) if filters else 1
            page_size = filters.get('page_size', 20) if filters else 20
            
            return paginate_queryset(queryset, page, page_size)
            
        except Exception as e:
            self.handle_service_error(e, "Failed to get stations list")
    
    @transaction.atomic
    def toggle_maintenance_mode(self, station_sn: str, is_maintenance: bool, 
                              reason: str, admin_user) -> Station:
        """Toggle station maintenance mode"""
        try:
            station = Station.objects.get(serial_number=station_sn)
            old_maintenance = station.is_maintenance
            
            station.is_maintenance = is_maintenance
            station.save(update_fields=['is_maintenance', 'updated_at'])
            
            # Log admin action
            AdminActionLog.objects.create(
                admin_user=admin_user,
                action_type='TOGGLE_MAINTENANCE',
                target_model='Station',
                target_id=str(station.id),
                changes={
                    'old_maintenance': old_maintenance,
                    'new_maintenance': is_maintenance,
                    'reason': reason
                },
                description=f"{'Enabled' if is_maintenance else 'Disabled'} maintenance mode",
                ip_address="127.0.0.1",
                user_agent="Admin Panel"
            )
            
            self.log_info(f"Maintenance mode {'enabled' if is_maintenance else 'disabled'} for station: {station.station_name}")
            return station
            
        except Station.DoesNotExist:
            raise ServiceException(
                detail="Station not found",
                code="station_not_found"
            )
        except Exception as e:
            self.handle_service_error(e, "Failed to toggle maintenance mode")
    
    def send_remote_command(self, station_sn: str, command: str, 
                          parameters: Dict[str, Any], admin_user) -> Dict[str, Any]:
        """Send remote command to station"""
        try:
            station = Station.objects.get(serial_number=station_sn)
            
            if station.status != 'ONLINE':
                raise ServiceException(
                    detail="Station must be online to receive commands",
                    code="station_offline"
                )
            
            # Create command payload
            command_payload = {
                'command': command,
                'parameters': parameters,
                'timestamp': timezone.now().isoformat(),
                'admin_user': admin_user.username
            }
            
            # Send command via MQTT (mock implementation)
            success = self._send_mqtt_command(station.imei, command_payload)
            
            # Log admin action
            AdminActionLog.objects.create(
                admin_user=admin_user,
                action_type='REMOTE_COMMAND',
                target_model='Station',
                target_id=str(station.id),
                changes={
                    'command': command,
                    'parameters': parameters,
                    'success': success
                },
                description=f"Sent remote command: {command}",
                ip_address="127.0.0.1",
                user_agent="Admin Panel"
            )
            
            self.log_info(f"Remote command sent to station: {station.station_name} - {command}")
            
            return {
                'command': command,
                'station_name': station.station_name,
                'success': success,
                'message': 'Command sent successfully' if success else 'Command failed to send'
            }
            
        except Station.DoesNotExist:
            raise ServiceException(
                detail="Station not found",
                code="station_not_found"
            )
        except Exception as e:
            self.handle_service_error(e, "Failed to send remote command")
    
    def _send_mqtt_command(self, imei: str, command_payload: Dict[str, Any]) -> bool:
        """Send MQTT command to station (mock implementation)"""
        try:
            # This would integrate with actual MQTT broker
            # For now, return True as mock success
            return True
        except Exception as e:
            self.log_error(f"MQTT command failed: {str(e)}")
            return False

    # ============================================================
    # Station Issue Management Methods
    # ============================================================
    
    def get_station_issues(
        self,
        status: str = None,
        priority: str = None,
        station_sn: str = None,
        issue_type: str = None,
        ordering: str = '-reported_at'
    ):
        """
        Get list of station issues with filtering
        
        Args:
            status: Filter by status (REPORTED, ACKNOWLEDGED, IN_PROGRESS, RESOLVED)
            priority: Filter by priority (LOW, MEDIUM, HIGH, CRITICAL)
            station_sn: Filter by station serial number
            issue_type: Filter by issue type
            ordering: Order by field
            
        Returns:
            Queryset of station issues
        """
        from api.stations.models import StationIssue
        
        queryset = StationIssue.objects.select_related(
            'station',
            'reported_by',
            'assigned_to'
        )
        
        # Apply filters
        if status:
            queryset = queryset.filter(status=status)
        
        if priority:
            queryset = queryset.filter(priority=priority)
        
        if station_sn:
            queryset = queryset.filter(station__serial_number=station_sn)
        
        if issue_type:
            queryset = queryset.filter(issue_type=issue_type)
        
        # Apply ordering
        queryset = queryset.order_by(ordering)
        
        return queryset
    
    def get_station_issue(self, issue_id: str):
        """
        Get specific station issue by ID
        
        Args:
            issue_id: Issue ID
            
        Returns:
            StationIssue instance
            
        Raises:
            ServiceException: If issue not found
        """
        from api.stations.models import StationIssue
        
        try:
            return StationIssue.objects.select_related(
                'station',
                'reported_by',
                'assigned_to'
            ).get(id=issue_id)
        except StationIssue.DoesNotExist:
            raise ServiceException(
                detail="Station issue not found",
                code="station_issue_not_found"
            )
    
    @transaction.atomic
    def update_station_issue(
        self,
        issue_id: str,
        admin_user,
        status: str = None,
        priority: str = None,
        assigned_to_id: str = None,
        notes: str = None,
        request=None
    ):
        """
        Update station issue status, priority, or assignment
        
        Args:
            issue_id: Issue ID
            admin_user: Admin user making the update
            status: New status
            priority: New priority
            assigned_to_id: User ID to assign to
            notes: Admin notes
            request: HTTP request for logging
            
        Returns:
            Updated StationIssue instance
        """
        from api.stations.models import StationIssue
        from django.contrib.auth import get_user_model
        
        User = get_user_model()
        
        try:
            issue = self.get_station_issue(issue_id)
            old_status = issue.status
            old_priority = issue.priority
            old_assigned = issue.assigned_to
            
            changes = {}
            
            # Update status
            if status and status != old_status:
                issue.status = status
                changes['status'] = {'old': old_status, 'new': status}
                
                # Auto-assign to current admin if status changed to IN_PROGRESS and not yet assigned
                if status == 'IN_PROGRESS' and not issue.assigned_to and not assigned_to_id:
                    issue.assigned_to = admin_user
                    changes['assigned_to'] = {
                        'old': None,
                        'new': admin_user.username,
                        'note': 'Auto-assigned when marked as IN_PROGRESS'
                    }
                
                # Mark as resolved if status is RESOLVED
                if status == 'RESOLVED' and not issue.resolved_at:
                    issue.resolved_at = timezone.now()
                    changes['resolved_at'] = issue.resolved_at.isoformat()
            
            # Update priority
            if priority and priority != old_priority:
                issue.priority = priority
                changes['priority'] = {'old': old_priority, 'new': priority}
            
            # Update assignment
            if assigned_to_id:
                try:
                    # assigned_to_id can be either AdminProfile UUID or User integer ID
                    # Try to get AdminProfile first (UUID), then fall back to User (int)
                    from api.admin.models import AdminProfile
                    
                    try:
                        # Try as AdminProfile UUID first
                        admin_profile = AdminProfile.objects.select_related('user').get(id=assigned_to_id)
                        assigned_user = admin_profile.user
                        
                        # Validate AdminProfile is active
                        if not admin_profile.is_active:
                            raise ServiceException(
                                detail="Cannot assign issue to inactive admin profile",
                                code="invalid_assignment_inactive_profile"
                            )
                    except (AdminProfile.DoesNotExist, ValueError):
                        # Try as User ID (integer) as fallback
                        assigned_user = User.objects.get(id=assigned_to_id)
                    
                    # Validate user is staff and active
                    if not assigned_user.is_staff:
                        raise ServiceException(
                            detail="Can only assign issues to staff members",
                            code="invalid_assignment_not_staff"
                        )
                    
                    if not assigned_user.is_active:
                        raise ServiceException(
                            detail="Cannot assign issue to inactive user",
                            code="invalid_assignment_inactive_user"
                        )
                    
                    issue.assigned_to = assigned_user
                    changes['assigned_to'] = {
                        'old': old_assigned.username if old_assigned else None,
                        'new': assigned_user.username
                    }
                except User.DoesNotExist:
                    raise ServiceException(
                        detail="Assigned user not found",
                        code="user_not_found"
                    )
            
            if notes:
                changes['notes'] = notes
            
            issue.save()
            
            # Log admin action
            self._log_admin_action(
                admin_user=admin_user,
                action_type='UPDATE_STATION_ISSUE',
                target_model='StationIssue',
                target_id=str(issue.id),
                changes=changes,
                description=f"Updated station issue {issue.id}",
                request=request
            )
            
            # Send notification to reporter if resolved
            if status == 'RESOLVED':
                self._send_issue_resolved_notification(issue, notes)
            
            self.log_info(f"Station issue {issue.id} updated by {admin_user.username}")
            return issue
            
        except ServiceException:
            raise
        except Exception as e:
            self.handle_service_error(e, "Failed to update station issue")
    
    @transaction.atomic
    def delete_station_issue(self, issue_id: str, admin_user, request=None):
        """
        Soft delete a station issue
        
        Args:
            issue_id: Issue ID
            admin_user: Admin user performing deletion
            request: HTTP request for logging
            
        Returns:
            Success message dict
        """
        try:
            issue = self.get_station_issue(issue_id)
            
            # Soft delete (mark as deleted)
            issue.delete()
            
            # Log admin action
            self._log_admin_action(
                admin_user=admin_user,
                action_type='DELETE_STATION_ISSUE',
                target_model='StationIssue',
                target_id=str(issue.id),
                changes={'deleted': True},
                description=f"Deleted station issue {issue.id}",
                request=request
            )
            
            self.log_info(f"Station issue {issue.id} deleted by {admin_user.username}")
            
            return {'message': 'Station issue deleted successfully'}
            
        except Exception as e:
            self.handle_service_error(e, "Failed to delete station issue")
    
    def _send_issue_resolved_notification(self, issue, notes: str = None):
        """Send notification to user when station issue is resolved"""
        try:
            from api.notifications.services import notify
            
            notify(
                issue.reported_by,
                'station_issue_resolved',
                station_name=issue.station.station_name,
                station_serial=issue.station.serial_number,
                issue_type=issue.get_issue_type_display(),
                notes=notes or 'Issue has been resolved'
            )
        except Exception as e:
            self.log_warning(f"Failed to send issue resolved notification: {str(e)}")
    
    def _log_admin_action(
        self,
        admin_user,
        action_type: str,
        target_model: str,
        target_id: str,
        changes: dict,
        description: str,
        request=None
    ):
        """Log admin action to audit trail"""
        try:
            from api.admin.models import AdminActionLog
            
            AdminActionLog.objects.create(
                admin_user=admin_user,
                action_type=action_type,
                target_model=target_model,
                target_id=target_id,
                changes=changes,
                description=description,
                ip_address=self._get_client_ip(request) if request else '',
                user_agent=request.META.get('HTTP_USER_AGENT', '') if request else ''
            )
        except Exception as e:
            self.log_error(f"Failed to log admin action: {str(e)}")
    
    def _get_client_ip(self, request) -> str:
        """Get client IP address from request"""
        x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
        if x_forwarded_for:
            ip = x_forwarded_for.split(',')[0]
        else:
            ip = request.META.get('REMOTE_ADDR')
        return ip
