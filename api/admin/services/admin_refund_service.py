"""
Service for admin refund management
============================================================

This module contains service classes for service for admin refund management.

Auto-generated by Service Separator
Date: 2025-10-18 23:39:20
"""
from __future__ import annotations
from typing import Dict, Any
from django.db import transaction
from django.utils import timezone
from django.db.models import Q
from api.common.services.base import CRUDService, ServiceException
from api.common.utils.helpers import paginate_queryset
from api.admin.models import AdminActionLog
from api.payments.models import Refund

# Additional imports for this module

class AdminRefundService(CRUDService):
    """Service for admin refund management"""
    model = Refund
    
    def get_pending_refunds(self, filters: Dict[str, Any] = None) -> Dict[str, Any]:
        """Get pending refund requests"""
        try:
            queryset = Refund.objects.filter(status='REQUESTED').select_related(
                'transaction', 'requested_by'
            )
            
            # Apply filters
            if filters:
                if filters.get('start_date'):
                    queryset = queryset.filter(requested_at__gte=filters['start_date'])
                
                if filters.get('end_date'):
                    queryset = queryset.filter(requested_at__lte=filters['end_date'])
                
                if filters.get('search'):
                    search_term = filters['search']
                    queryset = queryset.filter(
                        Q(transaction__transaction_id__icontains=search_term) |
                        Q(requested_by__username__icontains=search_term) |
                        Q(requested_by__email__icontains=search_term)
                    )
            
            # Order by latest first
            queryset = queryset.order_by('-requested_at')
            
            # Pagination
            page = filters.get('page', 1) if filters else 1
            page_size = filters.get('page_size', 20) if filters else 20
            
            return paginate_queryset(queryset, page, page_size)
            
        except Exception as e:
            self.handle_service_error(e, "Failed to get pending refunds")
    
    @transaction.atomic
    def process_refund(self, refund_id: str, action: str, admin_notes: str, admin_user) -> Refund:
        """Process refund request (approve/reject)"""
        try:
            refund = Refund.objects.get(id=refund_id, status='REQUESTED')
            
            if action == 'APPROVE':
                refund.status = 'APPROVED'
                refund.approved_by = admin_user
                refund.processed_at = timezone.now()
                
                # Process actual refund
                from api.payments.services import WalletService
                wallet_service = WalletService()
                
                wallet_service.add_balance(
                    user=refund.requested_by,
                    amount=refund.amount,
                    description=f"Refund for transaction {refund.transaction.transaction_id}"
                )
                
                # Update transaction status
                refund.transaction.status = 'REFUNDED'
                refund.transaction.save(update_fields=['status'])
                
                message = f"Refund of NPR {refund.amount} has been approved and processed."
                
            else:  # REJECT
                refund.status = 'REJECTED'
                refund.approved_by = admin_user
                refund.processed_at = timezone.now()
                message = f"Refund request has been rejected. Reason: {admin_notes}"
            
            # Add admin notes
            if admin_notes:
                refund.gateway_reference = admin_notes  # Using this field for admin notes
            
            refund.save(update_fields=['status', 'approved_by', 'processed_at', 'gateway_reference'])
            
            # Log admin action
            AdminActionLog.objects.create(
                admin_user=admin_user,
                action_type=f'REFUND_{action}',
                target_model='Refund',
                target_id=str(refund.id),
                changes={
                    'action': action,
                    'amount': str(refund.amount),
                    'transaction_id': refund.transaction.transaction_id,
                    'admin_notes': admin_notes
                },
                description=f"Refund {action.lower()}ed",
                ip_address="127.0.0.1",
                user_agent="Admin Panel"
            )
            
            # Send refund notification using clean API
            from api.notifications.services import notify
            template_slug = 'refund_approved' if action == 'APPROVED' else 'refund_rejected'
            notify(refund.requested_by, template_slug, amount=refund.amount, admin_notes=admin_notes)
            
            self.log_info(f"Refund {action.lower()}ed: {refund.id} by {admin_user.username}")
            return refund
            
        except Refund.DoesNotExist:
            raise ServiceException(
                detail="Refund request not found",
                code="refund_not_found"
            )
        except Exception as e:
            self.handle_service_error(e, "Failed to process refund")
